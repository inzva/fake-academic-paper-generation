\documentclass{article}

\PassOptionsToPackage{sort,numbers}{natbib}


\usepackage{ifthen}
\newboolean{arxiv}
\setboolean{arxiv}{true}

\usepackage[final]{neurips_2018}
\usepackage{booktabs}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography

\usepackage{graphicx}
\graphicspath{{figures_arxiv/}}
\usepackage{amsmath}
\usepackage{xcolor}


\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\usepackage{capt-of}


\newcommand{\TP}[1]{{\bf TP: #1}}
\newcommand{\JS}[1]{{\bf JS: #1}}
\makeatletter
\renewcommand*{\@fnsymbol}[1]{\ensuremath{\ifcase#1\or \or \or \or
\or \or \or \or \or \else\@ctrerr\fi}}
\newcommand{\affiliations}{
\vspace{-3.0em}
\begin{center}
$^1$DI ENS \quad \quad \quad  \quad  $^2$Inria  \quad \quad \quad \quad $^3$DeepMind \quad \quad  \quad \quad $^4$CIIRC, CTU in Prague
 \end{center}
 \vspace{1em}}
\@ifpackagewith{neurips_2018}{final}{\newcommand{\printaffiliations}{\affiliations}}{\newcommand{\printaffiliations}{}}
\@ifpackagewith{neurips_2018}{preprint}{\renewcommand{\printaffiliations}{\affiliations}}{\renewcommand{\printaffiliations}{}}
\makeatother


\begin{document}

\title{Neighbourhood Consensus Networks}

\author{
  Ignacio Rocco$^{\dagger}$ \\
  \And
  Mircea Cimpoi$^{\ddagger}$\\
  \And
  Relja Arandjelovi\'c$^{\S}$\\
  \And
  Akihiko Torii$^{\ast}$\\
  \And
  Tomas Pajdla$^{\ddagger}$\\
  \And
  Josef Sivic$^{\dagger,\ddagger}$
  \thanks{$^\dagger$WILLOW project, Dpartement d’informatique de l’cole normale suprieure,  ENS/INRIA/CNRS UMR 8548, PSL Research University, Paris, France.}\thanks{$^\ddagger$CIIRC -- Czech Institute of Informatics, Robotics and Cybernetics at the Czech Technical University in Prague, Czechia.}\\
  \AND
\normalfont
\normalsize\textsuperscript{$\dagger$}Inria\quad
\normalsize\textsuperscript{$\ddagger$}CIIRC, CTU in Prague\quad
\normalsize\textsuperscript{\S}DeepMind\quad
\normalsize\textsuperscript{$\ast$}Tokyo Institute of Technology
}
\maketitle


\begin{abstract}
We address the problem of finding reliable dense correspondences between a pair of images. This is a challenging task due to strong appearance differences between the corresponding scene elements and ambiguities generated by repetitive patterns. The contributions of this work are threefold. First, inspired by the classic idea of disambiguating feature matches using semi-local constraints,  we develop an end-to-end trainable convolutional neural network architecture that identifies sets of spatially consistent  matches by analyzing neighbourhood consensus patterns in the 4D space of all possible correspondences between a pair of images without the need for a global geometric model. Second, we demonstrate that the model can be trained effectively from weak supervision in the form of matching and non-matching image pairs without the need for costly manual annotation of point to point correspondences.
Third, we show the proposed neighbourhood consensus network can be applied to a range of matching tasks including both category- and instance-level matching, obtaining the state-of-the-art results on the PF Pascal dataset and the InLoc indoor visual localization benchmark.
\end{abstract}

\section{Introduction \label{sec:intro}}

Finding visual correspondences is one of the fundamental image understanding problems with applications in 3D reconstruction~\cite{agarwal2011building}, visual localization~\cite{Sattler18,Taira18} or object recognition~\cite{liu2008siftflow}. In recent years, significant effort has gone into developing trainable image representations for finding correspondences between images under strong appearance changes caused by viewpoint or illumination variations~\cite{jahrer2008learned, fischer2014descriptor, zagoruyko2015learning, han2015matchnet, balntas2016pn, ConvOpt,DeepDesc,TFeat,yi2016lift}. However, unlike in other visual recognition tasks, such as image classification or object detection, where trainable image representations have become the \emph{de facto} standard, the performance gains obtained by trainable features over the classic hand-crafted ones have been only modest at best~\cite{Schonberger_2017_CVPR}.

One of the reasons for this plateauing performance could be the currently dominant approach for finding image correspondence based on matching  {\em individual} image features.
While we have now better local patch descriptors, the matching is still performed by variants of the nearest neighbour assignment in a feature space followed by separate disambiguation stages based on geometric constraints. This approach has, however, fundamental limitations. Imagine a scene with textureless regions or repetitive patterns, such as a corridor with almost textureless walls and only few distinguishing features.
A small patch of an image, depicting a repetitive pattern or a textureless area, is indistinguishable from other portions of the image depicting the same repetitive or textureless pattern. Such matches will be either discarded~\cite{lowe2004distinctive} or incorrect. As a result, matching individual patch descriptors will often fail in such challenging situations.


In this work we take a different direction and develop a trainable neural network architecture that disambiguates such challenging situations by analyzing local neighbourhood patterns in a full set of dense correspondences. The intuition is the following: in order to disambiguate a match on a repetitive pattern, it is necessary to analyze a larger context of the scene that contains a unique non-repetitive feature. The information from this unique match can then be propagated to the neighbouring uncertain matches.
In other words, the certain unique matches will \emph{support} the close-by uncertain ambiguous matches in the image.

This powerful idea goes back to at least 1990s~\cite{zhang1995robust,schmid1997local,Schaffalitzky02a,Sivic03,bian2017gms}, and is typically known as \emph{neighbourhood consensus} or more broadly as \emph{semi-local constraints}. The neighbourhood consensus has been typically carried out on sparsely detected local invariant features as a filtering step performed \emph{after} a hard assignment of features by nearest neighbour matching using the Euclidean distance in the feature space.
Furthermore, the neighbourhood consensus has been evaluated by  manually engineered criteria,
such as a certain number of locally consistent matches~\cite{Schaffalitzky02a,Sivic03,bian2017gms}, or consistency in geometric parameters including distances and angles between matches~\cite{zhang1995robust,schmid1997local}.

In this work, we go one step further and propose a way of \emph{learning} neighbourhood consensus constraints directly from training data. Moreover, we perform neighbourhood consensus \emph{before} hard assignment of feature correspondence; that is, on the complete set of dense pair-wise matches. In this way, the decision on matching assignment is done only after taking into account the spatial consensus constraints, hence avoiding errors due to early matching decisions on ambiguous, repetitive or textureless matches.

\paragraph{Contributions.} We present the following contributions. First, we develop a neighbourhood consensus network -- a convolutional neural network architecture for dense matching that learns local geometric constraints between neighbouring correspondences without the need for a global geometric model. Second, we show that parameters of this network can be trained from scratch using a weakly supervised loss-function that requires supervision at the level of image pairs without the need for manually annotating individual correspondences.  Finally, we show that the proposed model is applicable to a range of matching tasks producing high-quality dense correspondences, achieving state-of-the-art results on both category- and instance-level matching benchmarks. Both training code and models are available at~\cite{website}.

\section{Related work}

This work relates to several lines of research, which we review below.


\paragraph{Matching with hand-crafted image descriptors.}
Traditionally, correspondences between images have been obtained by hand crafted local invariant feature detectors and descriptors~\cite{lowe2004distinctive,mikolajczyk2002affine,Tuytelaars08} that were extracted from the image with a controlled degree of invariance to local geometric and photometric transformations. Candidate (tentative) correspondences were then obtained by variants of nearest neighbour matching. Strategies for removing ambiguous and non-distinctive matches include the widely used second nearest neighbour ratio test~\cite{lowe2004distinctive}, or enforcing matches to be mutual nearest neighbours. Both  approaches work well for many applications, but have the disadvantage of discarding many correct matches, which can be problematic for challenging scenes, such as indoor spaces considered in this work that include repetitive and textureless areas. While successful, handcrafted descriptors have only limited tolerance to large appearance changes beyond the built-in invariance.


\paragraph{Matching with trainable descriptors.}
The majority of trainable image descriptors are based on convolutional neural networks (CNNs) and typically operate on patches extracted using a feature detector such as DoG~\cite{lowe2004distinctive}, yielding a sparse set of descriptors~\cite{jahrer2008learned, fischer2014descriptor, balntas2016pn, ConvOpt,DeepDesc,TFeat} or use a pre-trained image-level CNN feature extractor~\cite{noh2017large,Savinov17}. Others have recently developed trainable methods that comprise both feature detection and description~\cite{yi2016lift,choy_nips16,noh2017large}.
The extracted descriptors are typically compared using the Euclidean distance, but an appropriate similarity score can be also learnt in a discriminative manner~\cite{zagoruyko2015learning, han2015matchnet}, where a trainable model is used to both extract descriptors and produce a similarity score. Finding matches consistent with a geometric model is typically performed in a separate post-processing stage~\cite{long2014convnets,jahrer2008learned, fischer2014descriptor, balntas2016pn, ConvOpt,DeepDesc,TFeat,yi2016lift,choy_nips16,noh2017large}.


\paragraph{Trainable image alignment.}
Recently, end-to-end trainable methods have been developed to produce correspondences between images according to a parametric geometric model, such as an affine, perspective or thin-plate spline transformation~\cite{Rocco17,Rocco18}. In these works, all pairwise feature matches are computed and used to estimate the geometric transformation parameters using a CNN. Unlike previous methods that capture only a sparse set of correspondences, this geometric estimation CNN captures interactions between a full set of dense correspondences.
However, these methods currently only estimate a low complexity parametric transformation, and therefore their application is limited to only coarse image alignment tasks.
In contrast, we target a more general problem of identifying reliable correspondences between images of a general 3D scene. Our approach is not limited to a low dimensional parametric model, but outputs a generic set of locally consistent image correspondences, applicable to a wide range of computer vision problems ranging from category-level image alignment to camera pose estimation. The proposed method builds on the classical ideas of neighbourhood consensus, which we review next.

\paragraph{Match filtering by neighbourhood consensus.}
Several strategies have been introduced to decide whether a match is correct or not, given the supporting evidence from the neighbouring matches.  The early examples analyzed the patterns of distances~\cite{zhang1995robust} or angles~\cite{schmid1997local} between neighbouring matches. Later work simply counts the number of consistent matches in a certain image neighbourhood~\cite{Schaffalitzky02a,Sivic03}, which can be built in a scale invariant manner~\cite{Sattler09} or using a regular image grid~\cite{bian2017gms}. While simple, these techniques have been remarkably effective in removing random incorrect matches and disambiguating local repetitive patterns~\cite{Sattler09}. Inspired by this simple yet powerful idea we develop a neighbourhood consensus network -- a convolutional neural architecture that (i) analyzes the {\em full set of dense matches} between a pair of images and (ii) {\em learns} patterns of locally consistent correspondences directly from data.

\paragraph{Flow and disparity estimation.}
Related are also methods that estimate optical flow or stereo disparity such as \cite{lucas1981iterative,horn1981determining,Hirschmuller08,sun2010secrets,brox2011large}, or their trainable counterparts \cite{flownet,pwc,gcnet}. These works also aim at establishing reliable point to point correspondences between images. However, we address a more general matching problem where images can have large viewpoint changes (indoor localization) or major changes in appearance (category-level matching). This is different from optical flow where image pairs are usually consecutive video frames with small viewpoint or appearance changes, and stereo where matching is often reduced to a local search around epipolar lines. The optical flow and stereo problems are well addressed by specialized methods that explicitly exploit the problem constraints (such as epipolar line constraint, small motion, smoothness, etc.).

\section{Proposed approach}

In this work, we combine the robustness of neighbourhood consensus filtering with the power of trainable neural architectures. We design a model which learns to discriminate a reliable match by recognizing patterns of supporting matches in its neighbourhood. Furthermore, we do this in a fully differentiable way, such that this trainable matching
module can be directly combined with strong CNN image descriptors. The resulting pipeline can then be trained in an end-to-end manner for the task of feature matching. An overview of our proposed approach is presented in Fig.~\ref{fig:fext_and_matching}. There are five main components: (i) dense feature extraction and matching, (ii) the neighbourhood consensus network, (iii) a soft mutual nearest neighbour filtering, (iv) extraction of correspondences from the output 4D filtered match tensor, and (v) weakly supervised training loss. These components are described next.

\subsection{Dense feature extraction and matching}

\begin{figure}[t]
  \centering
    \includegraphics[width=\textwidth]{fext_and_matching}
    \caption{\small \textbf{Overview of the proposed method.} A fully convolutional neural network is used to extract dense image descriptors $f^A$ and $f^B$ for images $I_A$ and $I_B$, respectively. All pairs of individual feature matches $f^A_{ij}$ and $f^B_{kl}$ are represented in the 4-D space of matches $(i,j,k,l)$ (here shown as a 3-D perspective for illustration), and their matching scores stored in the 4-D correlation tensor $c$. These matches are further processed by the proposed soft-nearest neighbour filtering and neighbourhood consensus network (see Figure~\ref{fig:model}) to produce the final set of output correspondences.\label{fig:fext_and_matching}}
\end{figure}


In order to produce an end-to-end trainable model, we follow the common practice of using a deep convolutional neural network (CNN)
as a dense feature extractor.

Then, given an image $I$, this feature extractor will produce a dense set of descriptors, $\{f^I_{ij}\} \in \mathbb{R}^d$,
with indices $i=1,\dots,h$ and $j=1,\dots,w$, and $(h,w)$ denoting the number of features along image height and width
(\emph{i.e.}\the spatial resolution of the features), and $d$ the dimensionality of the features.

While classic hand-crafted neighbourhood consensus approaches are applied \emph{after} a hard assignment of matches is done, this is not well suited for developing a matching method that is differentiable and amenable for end-to-end training. The reason is that the step of selecting a particular match
is not differentiable with respect to the set of all the possible features. In addition, in case of repetitive features, assigning the match to the first nearest neighbour might result in an incorrect match, in which case the hard assignment would lose valuable information about the subsequent closest neighbours.


Therefore, in order to have an approach that is amenable to end-to-end training, all pairwise feature matches need to be computed and stored. For this we use an approach similar to~\cite{Rocco17}. Given two sets of dense feature descriptors $f^A=\{f^A_{ij}\}$ and $f^B=\{f^B_{ij}\}$ corresponding to the images to be matched, the exhaustive pairwise cosine similarities between them are computed and stored in a 4-D tensor $c\in \mathbb{R}^{h\times w\times h\times w}$ referred to as \emph{correlation map}, where:
\begin{equation}
    c_{ijkl}=\frac{\langle f^A_{ij}, f^B_{kl}\rangle}{{\|f^A_{ij}\|}_2 {\|f^B_{kl}\|}_2}.
    \label{eq:corrmap}
\end{equation}
Note that, by construction, elements of $c$ in the vicinity of index $ijkl$ correspond to matches between features that are in the local neighbourhoods $\mathcal{N}_A$ and $\mathcal{N}_B$ of descriptors $f^A_{ij}$ in image $A$ and $f^B_{kl}$ in image $B$, respectively, as illustrated in Fig.~\ref{fig:fext_and_matching}; this structure of the 4-D correlation map tensor $c$ will be exploited in the next section.

\subsection{Neighbourhood consensus network}
The correlation map contains the scores of \emph{all} pairwise matches. In order to further process and filter the matches, we propose to use 4-D convolutional neural network (CNN) for the neighbourhood consensus task (denoted by $N(\cdot)$), which is  illustrated in Fig.~\ref{fig:model}.

Determining the correct matches from the correlation map is, \emph{a priori}, a significant challenge. Note that the number of correct matches are of order of $hw$, while the size of the correlation map is of the order of $(hw)^2$. This means that the great majority of the information in the correlation map corresponds to \emph{matching noise} due to incorrectly matched features.

However, supported by the idea of neighbourhood consensus presented in Sec.~\ref{sec:intro}, we can expect correct matches to have a coherent set of supporting matches surrounding them in the 4-D space. These geometric patterns are equivariant with translations in the input images; that is, if the images are translated, the matching pattern is also translated in the 4-D space by an equal amount. This property motivates the use of 4-D convolutions for processing the correlation map as the same operations should be performed regardless of the location in the 4-D space. This is analogous to the motivation for using 2-D convolutions to process individual images -- it makes sense to use convolutions, instead of for example a fully connected layer, in order to profit from weight sharing and keep the number of trainable parameters low. Furthermore, it facilitates sample-efficient training as a single training example provides many error signals to the convolutional weights, since the \emph{same} weights are applied at all positions of the correlation map. Finally, by processing matches with a 4D convolutional network we establish a strong locality prior on the relationships between the matches. That is, by design, the network will determine the quality of a match by examining only the information in a local 2D neighbourhood in each of the two images.


 The proposed neighbourhood consensus network has several convolutional layers, as illustrated in Fig.~\ref{fig:model}, each followed by ReLU non-linearities. The convolutional filters of the first layer of the proposed CNN span a local 4-D region of the matches space, which corresponds to the Cartesian product of local neighbourhoods $\mathcal{N}_A$ and $\mathcal{N}_B$ in each image, respectively. Therefore, each 4-D filter of the first layer can process and detect patterns in all pairwise matches of these two neighbourhoods. This first layer has $N_1$ filters that can specialize in learning different local geometric deformations, producing $N_1$ output channels, that correspond to the agreement with these local deformations at each 4-D point of the correlation tensor.
 These output channels are further processed by subsequent 4-D convolutional layers. The aim is that these layers capture more complex patterns by combining the outputs from the previous layer, analogously to what has been observed for 2-D CNNs~\cite{zeiler2014visualizing}.
 Finally, the neighbourhood consensus CNN produces a single channel output, which has the same dimensions as the 4D input matches.

Finally, in order to produce a method that is invariant to the particular order of the input images, that is, that it will produce the same matches regardless of whether an image pair is input to the net as $(I^A,I^B)$ or $(I^B,I^A)$, we propose to apply the network twice in the following way:
\begin{equation}
    \tilde{c}=N(c)+{\left(N(c^\text{T})\right)}^\text{T},
\end{equation}
where by $c^\text{T}$ we mean swapping the pair of dimensions corresponding to the first and second images: $\left(c^\text{T}\right)_{ijkl}=c_{klij}$.
This final output constitutes the \emph{filtered matches} $\tilde{c}$ using the neighbourhood consensus network, where matches with inconsistent \emph{local} patterns are downweighted or removed. Further filtering can be done by means of a  \emph{global} filtering strategy, as presented next.

\begin{figure}[t]
  \centering
    \includegraphics[width=\textwidth]{model_new_dots}
    \caption{\small \textbf{Neighbourhood Consensus Network (NC-Net).} A neighbourhood consensus CNN operates on the 4D space of feature matches. The first 4D convolutional layer filters
    span $\mathcal{N}_A\times\mathcal{N}_B$, the Cartesian product of local neighbourhoods $\mathcal{N}_A$ and $\mathcal{N}_B$ in images $A$ and $B$ respectively. The proposed 4D neighbourhood consensus CNN can learn to identify the matching patterns of reliable and unreliable matches, and filter the matches accordingly.\label{fig:model}}
\end{figure}
\subsection{Soft mutual nearest neighbour filtering}
Although the proposed neighbourhood consensus network can suppress and amplify matches based on the supporting evidence in their neighbourhoods -- that is, at a semi-local level -- it cannot enforce global constraints on matches, such as being a \emph{reciprocal} match, where matched features are required to be mutual nearest neighbours:
\begin{equation}
    (f^A_{ab},f^B_{cd})\text{\, mutual N.N.} \iff   \begin{cases}
    (a,b) = \argmin_{ij} \| f^A_{ij}-f^B_{cd} \| \\
    (c,d) = \argmin_{kl} \| f^A_{ab}-f^B_{kl} \|.
    \end{cases}
    \label{eq:hard_mutual_nn}
\end{equation}
Filtering the matches by imposing the hard mutual nearest neighbour condition expressed by~\eqref{eq:hard_mutual_nn} would eliminate the great majority of candidate matches, which makes it unsuitable for usage in an end-to-end trainable approach, as this hard decision is non-differentiable.

We therefore propose a softer version of the mutual nearest neighbour filtering ($M(\cdot)$), both in the sense of \emph{softer decision} and \emph{better differentiability properties}, that can be applied on dense 4-D match scores:
\begin{equation}
   \hat{c}=M(c), \text{\quad where\quad } \hat{c}_{ijkl} = r^A_{ijkl} r^B_{ijkl} c_{ijkl},
\end{equation}
and $r^A_{ijkl}$ and $r^B_{ijkl}$ are the ratios of the score of the particular match $c_{ijkl}$ with the best scores along each pair of dimensions corresponding to images $A$ and $B$ respectively:
\begin{equation}
    r^A_{ijkl}=\frac{c_{ijkl}}{\max_{ab} c_{abkl}},\text{\quad and\quad }r^B_{ijkl}=\frac{c_{ijkl}}{\max_{cd} c_{ijcd}}.
\end{equation}
This soft mutual nearest neighbour filtering operates as a gating mechanism on the input, downweighting the scores of matches that are not mutual nearest neighbours. Note that the proposed formulation is indeed a \emph{softer} version of the mutual nearest neighbours criterion as $\hat{c}_{ijkl}$ equals the matching score $c_{ijkl}$ iff $(f^A_{ij},f^B_{kl})$ are mutual nearest neighbours, and is decreased to a value in $\left[0,c_{ijkl}\right)$ otherwise. On the contrary, the ``hard'' mutual nearest neighbour matching would assign $\hat{c}_{ijkl}=0$ in the latter case.


While this filtering step has no trainable parameters, it can be inserted in the CNN pipeline at both training and evaluation stages, and it will help to enforce the global \emph{reciprocity} constraint on matches. In the proposed approach, the soft mutual nearest neighbour filtering is used to filter both the correlation map, as well as the output of the neighbourhood consensus CNN, as illustrated in Fig.~\ref{fig:fext_and_matching}.

\subsection{Extracting correspondences from the correlation map \label{sec:match_assignment}}
Suppose that we want to match two images $I^A$ and $I^B$. Then, the output of our model will produce a 4-D filtered correlation map $c$, which contains (filtered) scores for all pairwise matches. However, for various applications, such as image warping, geometric transformation estimation, pose estimation, visualization, etc, it is desirable to obtain a set of point-to-point image correspondences between the two images.
To achieve this, a hard assignment can be performed in either of two possible directions, from features in image $A$ to features in image $B$, or vice versa.

For this purpose, two scores are defined from the correlation map, by performing soft-max in the dimensions corresponding to images $A$ and $B$:
\begin{equation}
    s^{A}_{ijkl}=\frac{\exp(c_{ijkl})}
    {\sum_{ab} \exp(c_{abkl})}
    \text{\quad and\quad}
    s^{B}_{ijkl}=\frac{\exp(c_{ijkl})}
    {\sum_{cd} \exp(c_{ijcd})}.
    \label{eq:softmax}
\end{equation}
Note that the scores are: (i) positive, (ii) normalized using the soft-max function, which makes $\sum_{ab} s^{B}_{ijab}=1$. Hence we can interpret them as discrete conditional probability distributions of $f^A_{ij},f^B_{kl}$ being a match, given the position $(i,j)$ of the match in $A$ or $(k,l)$ in $B$. If we denote $(I,J,K,L)$ the discrete random variables indicating the position of a match (\emph{a priori} unknown), and $(i,j,k,l)$ the particular position of a match, then:
\begin{equation}
\mathbb{P}\left(K=k,L=l\mid I=i,J=j\right)=s^B_{ijkl}\text{\quad and \quad}\mathbb{P}\left(I=i,J=j \mid K=k,L=l \right)=s^A_{ijkl}.
\label{eq:prob_dist}
\end{equation}
Then, the hard-assignment in one direction can be done by just taking the most likely match (the mode of the distribution):
\begin{equation}
\begin{split}
     f^B_{kl}\text{\,\,assigned to a given\,\,} f^A_{ij} \iff (k,l)& =
      \argmax_{cd} \mathbb{P}\left(K=c,L=d\mid I=i,J=j\right) \\
      &= \argmax_{cd} s^B_{ijcd},
     \label{eq:hard_assign}
\end{split}
\end{equation}
and analogously to obtain the matches $f^A_{ij}$ assigned to a given $f^B_{kl}$.

This probabilistic intuition allows us to model the match uncertainty using a probability distribution and  will be also useful to motivate the loss used for weakly-supervised training, which will be described next.

\subsection{Weakly-supervised training}
In this section we define the loss function used to train our network.
One option is to use a strongly-supervised loss, but this requires dense annotations consisting of all pairs of corresponding points for each training image pair. Obtaining such exhaustive ground-truth is complicated -- dense manual annotation is impractical, while sparse annotation followed by an automatic densification technique typically results in imprecise and erroneous training data. Another alternative is to resort to synthetic imagery which would provide point correspondences by construction, but this has the downside of making it harder to generalize to larger appearance variations encountered in real image pairs we wish to handle. Therefore, it is desirable to be able to train directly from pairs of real images, and using as little annotation as possible.

For this we propose to use a training loss that only requires a weak-level of supervision consisting of annotation on the level of image pairs.  These training pairs $(I^A,I^B)$ can be of two types, positive pairs, labelled with $y=+1$, or negative pairs, labelled with $y=-1$. Then, the following loss function is proposed:
\begin{equation}
    \mathcal{L}(I^A,I^B)=-y\left(\bar{s}^A + \bar{s}^B\right),
    \label{eq:loss}
\end{equation}
where $\bar{s}^A$ and $\bar{s}^B$ are the mean matching scores over all hard assigned matches as per~\eqref{eq:hard_assign} of a given image pair $(I^A,I^B)$ in both matching directions.

Note that the minimization of this loss maximizes the scores of positive and minimizes the scores of negative image pairs, respectively. As explained in~\ref{sec:match_assignment}, the hard-assigned matches correspond to the modes of the distributions of~\eqref{eq:prob_dist}. Therefore, maximizing the score forces the distribution towards a Kronecker delta distribution, having the desirable effect of producing well-identified matches in positive image pairs. Similarly, minimizing the score forces the distribution towards the uniform one, weakening the matches in the negative image pairs. Note that while the only scores that directly contribute to the loss are the ones coming from hard-assigned matches, all matching scores affect the loss because of the normalization in \eqref{eq:softmax}. Therefore, all matching scores will be updated at each training step.


\section{Experimental results}
The proposed approach was evaluated on both instance- and category-level matching problems. The same approach is used to obtain reliable matches for both problems, which are then used to solve two completely different tasks: (i) camera pose estimation in the challenging scenario of indoor localization, in the instance-level matching case, and (ii) semantic object alignment in the category-level matching case. Next we present the implementation details, followed by the results on the two tasks.

\paragraph{Implementation details.}
The model was implemented in PyTorch~\cite{pytorch}, and a ResNet-101 network~\cite{he2016deep} initialized on ImageNet was used for feature extraction (up to the \texttt{conv4\_23} layer). The neighbourhood consensus network $N(\cdot)$ contains three layers of $5\times 5\times 5\times 5$ filters or two layers of $3\times 3\times 3\times 3$ filters for category level and instance level matching, respectively. In both cases, the intermediate results have 16 channels ($N_1=N_2=16$).
A feature resolution of $25\times 25$ was used for training. As accurately localized features are needed for the pose estimation task, we extract correspondence for pose estimation at test time at a higher resolution resulting in a $200\times 150$ feature map, which is downsampled using 4-D max+argmax pooling operation after computing the correlation map to $100\times 75$ for increased efficiency.
The model is initially trained for 5 epochs using Adam optimizer~\cite{kingma2015adam}, with a learning rate of $5 \times 10^{-4}$ and keeping the feature extraction layer weights fixed.
For category level matching, the model is then subsequently finetuned for 5 more epochs, training both the feature extraction and the neighbourhood consensus network, with a learning rate of $1 \times 10^{-5}$. In the case of instance level matching, finetuning the feature extraction did not improve the performance. Additional implementation details are given in \ifthenelse{\boolean{arxiv}}{appendices~\ref{apx:4d_conv} and~\ref{apx:feature_reloc}}{the supplementary material~\cite{NCNet_arxiv}}.


\subsection{Category-level matching}
The proposed method was evaluated on the task of category-level matching, where, given two images containing different instances from the same category (\emph{e.g.} two different cat images) the goal is to match similar semantic parts.

\paragraph{Dataset and evaluation measure.}
We report results on the PF-Pascal~\cite{ham2017proposal} dataset, which contains 1,351 semantically related image pairs from the 20 object categories of the PASCAL VOC~\cite{pascal-voc-2011} dataset. We follow the same evaluation protocol as~\cite{scnet,Rocco18}, and use the split from~\cite{scnet} which divides the dataset into approximately 700 pairs for training, 300 for validation and 300 for testing. In order to train the network in a weakly-supervised manner using the proposed loss~\eqref{eq:loss}, the 700 training pairs are used as positive training pairs, and negative pairs are generated by randomly pairing images of different categories, such as a car with a dog image. The performance is measured using the percentage of correct keypoints (PCK), that is, number of correctly matched annotated keypoints.
\paragraph{Results.}
Quantitative results are presented in Table~\ref{tab:pf-pascal-baselines}. The proposed neighbourhood consensus network (NC-Net) obtains {\char`\~}3\% improvement over the state-of-the-art methods on this dataset~\cite{Rocco18}.
An example of semantic keypoint transfer is shown in Figure~\ref{fig:PF-Pascal-Example} and demonstrates how our approach can correctly match semantic object parts in challenging situations with large changes of appearance and non-rigid geometric deformations. See \ifthenelse{\boolean{arxiv}}{appendix~\ref{apx:cat_level}}{the supplementary material~\cite{NCNet_arxiv}} for additional examples.
\subsection{Instance-level matching}
Next we show that our method is also suitable for instance level matching and consider specifically the application to indoor visual localization, where the goal is to estimate an accurate 6DoF camera pose of a query photograph given a large-scale 3D model of a building. This is an extremely challenging instance-level matching task as indoor spaces are often self-similar and contain large textureless areas. We compare our method with the recently introduced indoor localization approach of~\cite{Taira18}, which is a strong baseline that outperforms several state-of-the-art methods, and introduces a challenging dataset for large scale indoor localization.

\paragraph{Dataset and evaluation measure.}
We evaluate on the InLoc dataset~\cite{Taira18},
which consists of 10K database images (perspective cutouts) extracted from 227 RGBD panoramas, and an additional set of 356 query images captured with a smart-phone camera at a different time from the database images. We follow the same evaluation protocol and report the percentage of correctly localized queries at a given camera position error threshold. As the InLoc dataset was designed for evaluation and does not contain a training set, we collected an Indoor Venues Dataset, consisting of user-uploaded photos, captured at public places such as restaurants, cafes, museums or cathedrals, by crawling Google Maps. It features similar appearance variations as the InLoc dataset, such as illumination changes, and scene modifications due to the passage of time. This dataset contains 3861 positive image pairs from 89 different venues in 6 different cities, split into \emph{train}: 3481 pairs (80 places) and \emph{validation}: 380 pairs (from the remaining 9 places). The design and collection procedures are described in \ifthenelse{\boolean{arxiv}}{appendix~\ref{apx:indoor_venues_dataset}}{the supplementary material~\cite{NCNet_arxiv}} and the dataset is available at~\cite{website}. As in the case of category-level matching, negative pairs were generated by randomly sampling images from different places.

 \begin{figure}[t]
  \begin{minipage}[t]{0.3\textwidth}
      \centering
    \setlength{\tabcolsep}{3pt}{\footnotesize
    \begin{tabular}{lc}
    \toprule
    Method &
    PCK
    \\ \midrule
    HOG+PF-LOM~\cite{ham2017proposal}   &   62.5    \\
    SCNet-AG+~\cite{scnet}              &   72.2    \\
    CNNGeo~\cite{Rocco17}               &   71.9    \\
    WeakAlign~\cite{Rocco18}            &   75.8    \\
    \textbf{NC-Net}                              &   \textbf{78.9}    \\
     \bottomrule
    \end{tabular}
    }{\scriptsize
    \captionof{table}{\small {\bf Results for semantic keypoint transfer.} We show the rate (\%) of correctly transferred keypoints within thresh.~$\alpha=0.1$.}
     \label{tab:pf-pascal-baselines} }
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.68\textwidth}
   \centering
    \setlength{\tabcolsep}{2pt}{\footnotesize
    \begin{tabular}{rccccccc}
    \toprule
 Dist. &
 SparsePE &
 DensePE &
 DensePE &
 DensePE &
 InLoc &
 InLoc &
 InLoc \\
 (m) &
 \cite{Taira18} &
 \cite{Taira18} &
 + MNN &
 + \textbf{NC-Net} &
 \cite{Taira18} &
 + MNN &
 + \textbf{NC-Net} \\
    \midrule
0.25 & 21.3 & 35.3 & 31.9 & 37.1 & 38.9 & 37.1 & {\bf 44.1} \\
0.50 & 30.7 & 47.4 & 50.5 & 53.5 & 56.5 & 60.2 & {\bf 63.8} \\
1.00 & 42.6 & 57.1 & 62.0 & 62.9 & 69.9 & 72.0 & {\bf 76.0} \\
2.00 & 48.3 & 61.1 & 64.7 & 66.3 & 74.2 & 76.3 & {\bf 78.4} \\
     \bottomrule
    \end{tabular}
    \vspace{-3pt}
    }{\scriptsize
    \captionof{table}{\small {\bf Comparison of indoor localization methods.} We show the rate (\%) of correctly localized queries within a given distance (m) and $10^\circ$ angular error. \label{tab:inloc-baselines}}}
    \end{minipage}
  \end{figure}
  \begin{figure}[t]
  \begin{minipage}[t]{0.42\textwidth}
    \centering
    \hspace*{-2mm}\begin{tabular}{cc}
 \includegraphics[width=\textwidth]{pfpascal/cats} \\
    \includegraphics[width=\textwidth]{pfpascal/34} \\
     \end{tabular}
     \captionof{figure}{\small {\bf Semantic keypoint transfer.} The annotated (ground truth) keypoints in the left image are automatically transferred to the right image using the dense correspondences between the two images obtained from our NC-Net.}
     \label{fig:PF-Pascal-Example}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.55\textwidth}
  \hspace*{-2mm}\begin{tabular}{cc}
\includegraphics[width=\linewidth]{cr/IMG_0823_DUC_cutout_002_60_-30_ncnet} \\
\includegraphics[width=\linewidth]{cr/IMG_0823_DUC_cutout_002_60_-30_hmm} \\
     \end{tabular}
     \captionof{figure}{\small {\bf Instance-level matching.} Top row: inlier correspondences (shown as green dots) obtained by our approach (InLoc+NC-Net). Bottom row: Baseline inlier correspondences  (InLoc+MNN). Our method provides a much larger and locally consistent set of matches, even in low-textured regions. Both methods use \emph{the same} CNN features.}
      \label{fig:InLoc-Example}
    \end{minipage}
  \end{figure}

\paragraph{Results.}
We plug-in our trainable neighbourhood consensus network (NC-Net) as a correspondence module into the InLoc indoor localization pipeline~\cite{Taira18}. We evaluate two variants of the approach. In the first variant, denoted DensePE+NC-Net,
the DensePE~\cite{Taira18} method is used for generating candidate image pairs, and then our network (NC-Net) is used to produce the correspondences that are employed for pose estimation.
In the second variant, denoted InLoc+NC-Net, we use the full InLoc pipeline, including pose-verification by view synthesis. In this case, matches produced by NC-Net are used as input for pose estimation for each of the top $N=10$ candidate pairs from DensePE, and the resulting candidate poses are re-ranked using pose-verification by view-synthesis.
As an ablation study, these two experiments are also performed when NC-Net is replaced with hard mutual nearest neighbours matching (MNN), using the same base CNN network (ResNet-101).
Results are summarised in Table~\ref{tab:inloc-baselines} and clearly demonstrate benefits of our approach ({DensePE+NC-Net}) compared to both sparse keypoint (DoG+SIFT) matching ({SparsePE}) and the CNN feature matching used in~\cite{Taira18} ({DensePE}). When inserted into the entire localization pipeline, our approach ({InLoc + NC-Net}) obtains state-of-the-art results on the indoor localization benchmark.
An example of obtained correspondences on a challenging indoor scene with repetitive structures and texture-less areas is shown in figure~\ref{fig:InLoc-Example}.
Additional results are shown in \ifthenelse{\boolean{arxiv}}{appendix~\ref{apx:inst_level}}{the supplementary material~\cite{NCNet_arxiv}}.

\subsection{Limitations}
While our method identifies correct matches in many challenging cases, some situations remain difficult. The two typical failure modes include: repetitive patterns combined with large changes in scale, and locally geometrically consistent groups of incorrect matches. Furthermore, the proposed method has quadratic $O(N^2)$ complexity with respect to the number of image pixels (or CNN features) $N$. This limits the resolution of the images that we are currently able to handle to $1600\times1200$px (or $3200\times2400$px if using the 4-D max+argmax pooling operation).

\section{Conclusion}
We have developed a neighbourhood consensus network  a CNN architecture  that learns local patterns of correspondences for image matching without the need for a global geometric model. We have shown the model can be trained effectively from weak supervision and obtains strong results outperforming state-of-the-art on two very different matching tasks.  These results open up the possibility for end-to-end learning of other challenging visual correspondence tasks, such as 3D category-level matching~\cite{Kanazawa18}, or visual localization across day/night illumination~\cite{Sattler18}.

\section*{Acknowledgements}

This work was partially supported by
JSPS KAKENHI Grant Numbers 15H05313, 16KK0002, EU-H2020 project LADIO No. 731970, ERC
grant LEAP No. 336845, CIFAR Learning in Machines
\& Brains program and the European Regional
Development Fund under the project IMPACT (reg.
no. CZ.02.1.01/0.0/0.0/15 003/0000468).

\bibliography{shortstrings,biblio}
\bibliographystyle{abbrv}

\clearpage
\appendix
\section*{{\Large Appendices}}
In these appendices we provide additional technical details, experimental results, and details about the dataset used. First, in appendices~\ref{apx:4d_conv} and~\ref{apx:feature_reloc} we present additional implementation details concerning 4D convolutions and the relocalization of features. Then, in appendices~\ref{apx:cat_level} and~\ref{apx:inst_level} we present additional experimental results for category-level and instance-level matching, respectively. Finally, in appendix~\ref{apx:indoor_venues_dataset}, we provide additional details about the Indoor Venues Dataset (IVD), which we used for instance-level matching.
As 4D convolutions are not currently supported by the deep learning framework which we used (\emph{i.e.} PyTorch~\cite{pytorch}), we implemented them by aggregating the results of multiple 3D convolutions. The same idea had been used in the past to obtain 3D convolutions by aggregating the results of multiple 2D convolutions, before 3D convolutions where natively supported.

Here we present the details of the technique used for improving the accuracy of the localization of the features, which is particularly important in the case of instance-level matching for the task of camera pose estimation.

The localization precision of the extracted features $f^I_{ij}$ depends on the spatial resolution $h\times w$ of the dense feature map $f^I$. For some tasks, such as pose estimation, precisely localized features are needed. However, in some cases, given hardware constraints, one cannot increase the spatial resolution $h\times w$ to obtain the required precision, as increasing $h$ and $w$ by a factor of two results in a sixteen time increase in the memory consumption and computation time. Therefore, we devise a method to increase the localization precision, with a less severe impact on the memory consumption and computation time.

In this approach, the correlation map $c$ from Eq.~\eqref{eq:corrmap} is computed with higher resolution features $2h
\times 2w$ leading to a $2h \times 2w\times 2h\times 2w$ correlation map resolution. However, this correlation map $c$ is then downsampled to resolution $h\times w\times h\times w$ before further processing by the neighbourhood consensus network. This downsampling is performed by a 4-D max-pooling operation, with the kernel of size 2:

\begin{equation}
    c^{*}_{abcd}=\max_{i\in[2a,2a+1],j\in[2b,2b+1],k\in[2c,2c+1],l\in[2d,2d+1]} c_{ijkl}.
\end{equation}

The downsampled correlation map $c^{*}$ is then processed and used to compute the final matches, which are localized with a precision given by the downsampled resolution $h\times w$.
However, one can \emph{re-localize} these features, and reduce the localization error, by simply extracting the following \emph{relocalization shifts} from the 4-D max-pooling operation:

\begin{equation}
    \delta_a,\delta_b,\delta_c,\delta_d =\argmax_{i\in[2a,2a+1],j\in[2b,2b+1],k\in[2c,2c+1],l\in[2d,2d+1]} c_{ijkl}.
\end{equation}

Then for a match $(f^A_{ab},f^B_{cd})$, the final \emph{re-localized} feature positions $(a',b')$ and $(c',d')$ are computed by:

\begin{equation}
\begin{split}
a'&=a+\delta_a/2,\\
b'&=b+\delta_b/2,\\
c'&=c+\delta_c/2,\\
d'&=d+\delta_d/2.
\end{split}
\end{equation}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{Additional results for category-level matching\label{apx:cat_level}}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In Figures~\ref{fig:qualPascal} and ~\ref{fig:qualPascal2} we present additional qualitative results for the task of keypoint transfer. We show a set of randomly sampled examples from the test set of the PF-Pascal dataset. In some cases the ground truth annotations are ambiguous. For instance, in the cat example in Fig.~\ref{fig:qualPascal}, where one of the keypoints could be both on the right side of the face or the back of the cat.

\begin{figure}[tbp]
  \centering
  \begingroup
  \renewcommand{\arraystretch}{0.5}
  \begin{tabular}{@{\hskip 1pt}c@{\hskip 6pt}|@{\hskip 6pt}c@{\hskip 1pt}}
    Ours & Ground-truth \\ \hline
    ~ & ~ \\
\includegraphics[width=0.45\linewidth]{pfpascal/154}  &
\includegraphics[width=0.45\linewidth]{pfpascal/154_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/295}  &
\includegraphics[width=0.45\linewidth]{pfpascal/295_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/125}  &
\includegraphics[width=0.45\linewidth]{pfpascal/125_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/105}  &
\includegraphics[width=0.45\linewidth]{pfpascal/105_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/35}  &
\includegraphics[width=0.45\linewidth]{pfpascal/35_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/7}  &
\includegraphics[width=0.45\linewidth]{pfpascal/7_GT} \\


  \end{tabular}
  \endgroup
  \vspace{2pt}
  \caption{{\bf Additional examples of semantic  keypoint  transfer.} The left column shows the (manually annotated) keypoints automatically transferred from the left to the right image using our NC-Net. The right column shows the ground-truth correspondence annotations.}
  \label{fig:qualPascal}
\end{figure}\begin{figure}[tbp]
  \centering
  \begingroup
  \renewcommand{\arraystretch}{0.5}
  \begin{tabular}{@{\hskip 1pt}c@{\hskip 6pt}|@{\hskip 6pt}c@{\hskip 1pt}}
    Ours & Ground-truth \\ \hline
    ~ & ~ \\
\includegraphics[width=0.45\linewidth]{pfpascal/86}  &
\includegraphics[width=0.45\linewidth]{pfpascal/86_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/267}  &
\includegraphics[width=0.45\linewidth]{pfpascal/267_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/240}  &
\includegraphics[width=0.45\linewidth]{pfpascal/240_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/71}  &
\includegraphics[width=0.45\linewidth]{pfpascal/71_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/32}  &
\includegraphics[width=0.45\linewidth]{pfpascal/32_GT} \\
\includegraphics[width=0.45\linewidth]{pfpascal/11}  &
\includegraphics[width=0.45\linewidth]{pfpascal/11_GT} \\
  \end{tabular}
  \endgroup
  \vspace{2pt}
  \caption{{\bf Additional examples of semantic  keypoint  transfer.} The left column shows the (manually annotated) keypoints automatically transferred from the left to the right image using our NC-Net. The right column shows the ground-truth correspondence annotations.}
  \label{fig:qualPascal2}
\end{figure}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{Additional results for instance-level matching\label{apx:inst_level}}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We illustrate situations in which our proposed method successfully localizes the query images within 2 meters and 10$^\circ$ with respect to the reference pose, while the baseline method fails. We show qualitative examples of the results obtained by the proposed method InLoc+NC-Net versus
DensePE (figure~\ref{fig:densePE}), InLoc (figure~\ref{fig:densePV}),
and InLoc+MNN (figure~\ref{fig:densePV_MNN}) baselines.
The matches (green dots) obtained by the proposed method tend to cover a larger space in the scene that enables a more accurate pose estimation in comparison with the baseline methods. Furthermore, these matches tend to be more geometrically consistent than those produced by the baselines.

Figure~\ref{fig:inloc-curves} shows the detailed results of camera localization that correspond to Table~2 in the main paper. It clearly shows the proposed NC-Net consistently improves over the state of the art DensePE and InLoc methods, as well as over the strong InLoc+MNN baseline which uses the \emph{same} ResNet-101 dense features as NC-Net.

  \centering
  \begingroup
  \renewcommand{\arraystretch}{0.5}
  \begin{tabular}{@{\hskip 1pt}c@{\hskip 6pt}|@{\hskip 6pt}c@{\hskip 1pt}}
    Ours (InLoc+NC-Net) & Baseline (DensePE) \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1035_DUC_cutout_033_270_0_perr_0.74629_orierr_2.3114_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1035_DUC_cutout_033_270_0_perr_4.4387_orierr_2.2529_dpe}}} \\
    0.75m, 2.31$^\circ$ & 4.44m, 2.25$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0753_DUC_cutout_014_270_0_perr_0.6085_orierr_1.7991_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0753_DUC_cutout_014_270_0_perr_7.3471_orierr_29.6229_dpe}}} \\
    0.61m, 1.80$^\circ$ & 7.34m, 29.62$^\circ$ \\ \hline
    ~ & ~ \\
     \includegraphics[width=0.45\linewidth]{{{cr/IMG_1027_DUC_cutout_034_0_0_perr_0.42028_orierr_0.6696_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1027_DUC_cutout_034_0_0_perr_3.131_orierr_6.9692_dpe}}} \\
    0.42m, 0.67$^\circ$ & 3.13m, 6.97$^\circ$ \\ \hline
    ~ & ~ \\
     \includegraphics[width=0.45\linewidth]{{{cr/IMG_0739_DUC_cutout_003_30_0_perr_0.31078_orierr_0.90716_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0739_DUC_cutout_003_30_0_perr_7.5333_orierr_45.0445_dpe}}} \\
    0.31m, 0.91$^\circ$ & 7.53m, 45.04$^\circ$ \\
  \end{tabular}
  \endgroup
  \vspace{2pt}
  \caption{{\bf Examples of query images that are more accurately localized using the proposed approach (left) than with the densePE baseline (right).} The numbers below each pair of images show the localization error (meters, degrees) with respect to the reference camera pose. Green dots show inlier matches used for camera pose estimation.}
  \label{fig:densePE}
\end{figure}% baseline: densePV\begin{figure}[tbp]
  \centering
  \begingroup
  \renewcommand{\arraystretch}{0.5}
  \begin{tabular}{@{\hskip 1pt}c@{\hskip 6pt}|@{\hskip 6pt}c@{\hskip 1pt}}
    Ours (InLoc+NC-Net) & Baseline (InLoc) \\ \hline
     ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1030_DUC_cutout_035_30_0_perr_0.39215_orierr_1.7293_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1030_DUC_cutout_035_30_0_perr_2.9576_orierr_18.1167_dpv}}} \\
    0.39m, 1.73$^\circ$ & 2.96m, 18.12$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0742_DUC_cutout_003_60_0_perr_0.36417_orierr_1.9274_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0742_DUC_cutout_003_60_0_perr_8.1055_orierr_48.3805_dpv}}} \\
    0.36m, 1.93$^\circ$ & 8.11m, 48.38$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0866_DUC_cutout_008_90_0_perr_0.024091_orierr_1.0651_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0866_DUC_cutout_008_90_0_perr_2.7289_orierr_3.2284_dpv}}} \\
    0.02m, 1.07$^\circ$ & 2.73m, 3.23$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0834_DUC_cutout_012_150_0_perr_0.40872_orierr_0.83217_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0834_DUC_cutout_012_150_0_perr_6.6528_orierr_23.8567_dpv}}} \\
    0.41m, 0.83$^\circ$ & 6.65m, 23.86$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0936_DUC_cutout_068_150_0_perr_0.3598_orierr_3.4083_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0936_DUC_cutout_068_150_0_perr_3.3627_orierr_4.9008_dpv}}} \\
    0.36m, 3.40$^\circ$ & 3.36m, 4.90$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0743_DUC_cutout_010_330_0_perr_0.50741_orierr_0.99083_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0743_DUC_cutout_010_330_0_perr_9.3614_orierr_23.7177_dpv}}} \\
    0.51m, 0.99$^\circ$ & 9.36m, 23.72$^\circ$
  \end{tabular}
  \endgroup
  \vspace{2pt}
  \caption{{\bf Examples of query images that are more accurately localized using the proposed approach (left) than with the InLoc baseline (right)}. The numbers below each pair of images show the localization error (meters, degrees) with respect to the reference camera pose. Green dots show inlier matches used for camera pose estimation.}
  \label{fig:densePV}
\end{figure}% baseline: densePV+MNN\begin{figure}[tbp]
  \centering
  \begingroup
  \renewcommand{\arraystretch}{0.5}
  \begin{tabular}{@{\hskip 1pt}c@{\hskip 6pt}|@{\hskip 6pt}c@{\hskip 1pt}}
    Ours (InLoc+NC-Net) & Baseline (InLoc+MNN) \\ \hline
     ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0982_DUC_cutout_036_60_0_perr_0.039554_orierr_1.5162_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0982_DUC_cutout_036_60_0_perr_2.7119_orierr_9.5623_mnn}}} \\
    0.04m, 1.52$^\circ$ & 2.71m, 9.56$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1077_DUC_cutout_035_150_0_perr_1.1782_orierr_4.951_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1077_DUC_cutout_035_150_0_perr_2.1076_orierr_9.2522_mnn}}} \\
    1.18m, 4.95$^\circ$ & 2.11m, 9.25$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1091_DUC_cutout_117_240_0_perr_0.35461_orierr_5.3801_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_1091_DUC_cutout_117_240_0_perr_3.7764_orierr_24.7402_mnn}}} \\
    0.35m, 5.38$^\circ$ & 3.78m, 24.74$^\circ$ \\ \hline
    ~ & ~ \\
    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0766_DUC_cutout_007_90_0_perr_0.80507_orierr_1.6235_ncnet}}} &    \includegraphics[width=0.45\linewidth]{{{cr/IMG_0766_DUC_cutout_007_90_0_perr_2.8885_orierr_12.7075_mnn}}} \\
    0.81m, 1.62$^\circ$ & 2.89m, 12.71$^\circ$
  \end{tabular}
  \endgroup
  \vspace{2pt}
  \caption{{\bf Examples of query images that are more accurately localized using the proposed approach (left) than with the InLoc+MNN baseline (right)}. In this ablation study, both methods use \emph{the same} CNN features. The numbers below each pair of images show the localization error (meters, degrees) with respect to the reference camera pose. Green dots show inlier matches used for camera pose estimation.}
  \label{fig:densePV_MNN}
\end{figure}\begin{figure}[t]
    \centering
    \includegraphics[width=0.5\linewidth]{nips18_inloc}
    \caption{{\bf Comparison with the state of the art large-scale indoor localization~[31].} Plots show the fraction of correctly localized queries (y-axis) within a certain distance (x-axis) whose rotation error is at most  $10^{\circ}$. }
    \label{fig:inloc-curves}
\end{figure}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{The Indoor Venues Dataset (IVD)\label{apx:indoor_venues_dataset}}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We collected the Indoor Venues Dataset (IVD) to train our network (NC-Net) for instance-level matching, as the InLoc \cite{Taira18} dataset
 used for evaluation does not provide any training data.
The IVD consists of 3861 positive image pairs, collected from 89 venues (restaurants, cafes, museums), from six European cities (Amsterdam, Brussels, Copenhagen, Edinburgh, Paris and Prague), keeping 10\% for validation, and using the rest for training.
These positive image pairs consist of user-uploaded images
from the same indoor scene or location (\emph{i.e.} same room) captured at different points in time and which, despite the variations in viewpoint, depict the same 3D structures.  The image pairs contain a challenging level of variability in both viewpoint and illumination, as well as small variations in the scene due to the passage of time. These variations match well the challenging settings in the InLoc dataset. Examples of such images are shown in Figure~\ref{fig:ivd-dataset}.

The images were gathered from Google Maps\footnote{\url{https://maps.google.com/}}, which lists 100 million places, has 25 million daily updates, and 1 billion monthly active users\footnote{According to \url{https://cloud.google.com/maps-platform/places/}, as of October 2018.}. The availability of such a large number of user submitted content (reviews, photos, panoramas) makes it a suitable source for realistic indoor images.
We selected 6 touristic cities in Europe, for which we used Google Maps API
to search for venues in the selected cities, based on city centre GPS coordinates, and a search radius of 5-10 km. Only venues with at least 150 submitted reviews where used.

However, a large fraction (> 50 \%)
of these images where non-relevant for our task (images of food, selfies, outdoor images, photographs of the menu, etc). Therefore, a classifier was trained for curating the downloaded images in an automatic way. We used four classes, based on the most frequent categories of images present: food, indoor, outdoor and other (for less frequent types of images, like menus or selfies). For this, we used a ResNet-50 model~\cite{he2016deep}, pretrained on ImageNet as fixed feature extractor, and trained only the fully connected layer, on a subset of manually picked images (\textasciitilde{}1000/class).

From the curated indoor images, we then sampled 20 query images for each venue, and matched them against all the indoor images from the same place, using a NC-Net model trained on the PF-Pascal dataset. The resulting image pairs were manually inspected and filtered to make sure they depict the same part of the scene.

The dataset is publicly available at \url{http://www.di.ens.fr/willow/research/ncnet/}.

\begin{figure}[tbp]
  \centering
  \includegraphics[width=\linewidth]{ivd_dataset}
\caption{{\bf Indoor Venues Dataset (IVD)}. We show some examples of venues across 6 European cities, from which we collected images submitted by users on Google Maps. Note the variability in illumination, viewpoint, scene layout and occluders (people).}
  \label{fig:ivd-dataset}
\end{figure}

\end{document}


