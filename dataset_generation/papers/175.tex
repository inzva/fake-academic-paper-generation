\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{cvpr}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{url}
\usepackage{listings}
\usepackage{framed}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{mdwlist}
\usepackage{caption}
\usepackage{subcaption}

\newcommand{\SotA}{state-of-the-art }
%\newcommand{\etal} {\emph{et al.}}
\newcommand{\dropin}{DropIn }
\newcommand{\dropinNS}{DropIn}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

% Include other packages here, before hyperref.

% If you comment hyperref and then uncomment it, you should delete
% egpaper.aux before re-running latex.  (Or just hit 'q' on the first latex
% run, let it finish, and you should be clear).
\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}

\cvprfinalcopy % *** Uncomment this line for the final submission

\def\cvprPaperID{495} % *** Enter the CVPR Paper ID here
\def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

% Pages are numbered in submission mode, and unnumbered in camera-ready
%\ifcvprfinal\pagestyle{empty}\fi
\begin{document}

%%%%%%%%% TITLE
\title{Gradual DropIn of Layers to Train Very Deep Neural Networks}

\author{
Leslie N. Smith\\
Naval Research Laboratory\\
%4555 Overlook Ave, Washington, DC \\
{\tt\small leslie.smith@nrl.navy.mil}\\
\and
Emily M. Hand\\
University of Maryland\\
%4438 A.V. Williams, College Park, MD\\
{\tt\small emhand@cs.umd.edu}
\and
Timothy Doster\\
Naval Research Laboratory\\
%4555 Overlook Ave, Washington, DC\\
{\tt\small timothy.doster@nrl.navy.mil}\\
}

\maketitle
%\thispagestyle{empty}

%%%%%%%%% ABSTRACT
\begin{abstract}


We introduce the concept of dynamically growing a neural network during training. In particular, an untrainable deep network starts as a trainable shallow network and newly added layers are slowly, organically added during training, thereby increasing the network's depth. This is accomplished by a new layer, which we call \dropinNS. The \dropin layer starts by passing the output from a previous layer (effectively skipping over the newly added layers), then increasingly including units from the new layers for both feedforward and backpropagation. We show that deep networks, which are untrainable with conventional methods, will converge with \dropin layers interspersed in the architecture. In addition, we demonstrate that \dropin provides regularization during training in an analogous way as dropout. Experiments are described with the MNIST dataset and various expanded LeNet architectures, CIFAR-10 dataset with its architecture expanded from 3 to 11 layers, and on the ImageNet dataset with the AlexNet architecture expanded to 13 layers and the VGG 16-layer architecture.

\end{abstract}

%%%%%%%%% BODY TEXT
\section{Introduction}

\label{sec:intro}

Over the past few years, \SotA results for image recognition \cite{Alexnet12,  simonyan2014very,szegedy2014going}, object detection \cite{girshick2014rich}, face recognition \cite{taigman2014deepface}, speech recognition \cite{graves2014towards}, machine translation \cite{sutskever2014sequence}, image caption generation \cite{vinyals2014show}, driverless car technology \cite{huval2015empirical}, and other applications \cite{lecun2015deep} have required increasingly deeper neural networks. 
%We propose \dropin as a way to train these deep networks.


Network depth refers to the number of layers in the architecture. 
It is well known that adding layers to neural networks makes them more expressive \cite{montufar2014number}. 
Each year, the Imagenet Challenge \cite{Imagenet15} is held in which teams are expected, given an image, to detect, localize, or recognize an object in the image. 
%The Imagenet Challenge, with over 1000 object categories, is considered the current benchmark for object detection, localization, and recognition tasks. 
Deep convolutional neural networks (CNNs) have dominated the competition since Krizhevsky \etal won in 2012 \cite{Alexnet12}, and each year since, the winner of the competition used a deeper network than the previous year's winner \cite{Imagenet15, simonyan2014very, szegedy2014going}.
%, e.g. the winner in 2012 used 8 layers while in 2014 the winner used 19 layers. 

However, training a very deep network is a difficult and open research problem \cite{erhan2009difficulty, glorot2010understanding, srivastava2015training}. 
It is difficult to train very deep networks because the error norm during backpropagation can grow or vanish exponentially.
In addition, very large training datasets are necessary when the network has millions of weights.

Here we suggest a dynamic architecture that grows during the training process and allows for the training of very deep networks.
We illustrate this with our \dropin layer, where new layers are skipped at the start of the training, as though they were not present.
This allows the weights of the included layers to start converging.
Over a number of iterations the \dropin layer increasingly includes activations from the inserted layers, which gradually trains the weights in theses added layers. 

\dropin follows the philosophy embedded within curriculum learning \cite{bengio2009curriculum}.
With curriculum learning one starts with an easier problem and incrementally increases the difficulty.
Here too, one starts training a shallow architecture and after convergence begins, \dropin incrementally modifies the architecture to slowly include units from the new layers.
%In \cite{gulccehre2013knowledge} the authors build upon the ideas of curriculum learning to include intermediate levels of guidance in the learning process.  

In addition, \dropin can be used in a mode analogous to dropout \cite{srivastava2014dropout} for the regularization of a deep neural network during training.  
Instead of setting random activations to zero, as is done in dropout, \dropin sets these activations to the activations from a previous layer.
% leading to a more robust trained network.
%This provides some of the benefits from regularization that dropout offers.
We demonstrate that the ``noise'' from mixing the activations from previous layers provides regularization during training. 
In addition, both \dropin and dropout can be viewed as training a large collection of networks with varied architectures and extensive weight sharing.

The contributions of this paper are:
\begin{enumerate*}
  \vspace{-10pt}
\item A dynamic architecture that can grow during training.  
\item The details of a \dropin layer for enabling the training of very deep networks and for regularization during training.  
%Also, a Resize layer is described to enable using \dropin even when the two input layers' sizes are different. 
\item Examples of successfully training deep architectures that cannot be trained with conventional methods on MNIST, CIFAR-10, and ImageNet.
%\item A method to discover an optimal architecture for a given application and dataset.
\end{enumerate*}

%-------------------------------------------------------------------------


\section{Related work}
%There has been a limited amount of work in recent years on how to train very deep networks.  
Methods for training very deep networks  have centered on initialization of the network weights or developing new architectures and \dropin is in the latter category.  
%There has been somewhat more work on regularizing the networks, this has come manly in the form of dropout.  
%We will now provide a brief review of the current state of initialization of network weights, new architecture for very deep networks, and regularization of networks.  We will also mention how \dropin will relate to this methods.  


\subsection{Initialization of network weights}
Sutskever \etal \cite{sutskever2013importance} investigate the difficulty in training deep networks and conclude that both proper initialization and momentum are necessary.  Glorot and Bengio \cite{glorot2010understanding} recommend an initialization method called \textit{normalized initialization} to allow the training of deep networks.  
%In this method weights are chosen from a distribution %$$W\sim  U[-6/\sqrt{n_j+n_{j+1}},6/\sqrt{n_j+n_{j+1}} ]$$ 
%such that the activation variance and the backpropagation variance are maintained throughout the network.  Using normalized initialization improved convergence during training.  
He \etal \cite{he2015delving} recently improved  upon the ``normalized initialization'' method by changing the distribution to take into account ReLU layers.  

Hinton \etal \cite{hinton2006fast} proposed first training layer by layer in an unsupervised fashion so that a transformed version of the input could be realized.  
%This method is able to capture the main variation of the input layer by layer.  Finally supervised fine-tuning occurs on the pre-trained weights.     
Erhan  \cite{erhan2009difficulty} later characterized the mathematics of the unsupervised pre-training and offered an explanation for its success.   

Sussillo and Abbott \cite{sussillo2015random} suggest an initialization scheme called \textit{Random Walk Initialization} based on scaling the initial random matrices correctly.  
By multiplying the error gradient by a correctly scaled random matrix at each layer, an unbiased  random walk is formed.  
%It can shown that the variance of the random walk grows only linearly with the depth of the network and thus the growing backpropagation error can be handled by increasing the size of the layers.  
This is one of only a few papers that show the results of experiments with networks consisting of hundreds of layers.  
%The results in this paper indicated that just adding layers does not necessarily improve accuracy results, which we also found to be true.

\subsection{Developing new architecture}

Raiko, \etal \cite{raiko2012deep} introduce the concept of skip connections by adding a linear transformation to the usual non-linear transformation of the input to a unit.  
Skip connections separate the linear and non-linear portions of the activations and allow the linear part to ``skip'' to higher layers.
This is similar to \dropin in some ways, but the purpose of \dropin differs from that of skip connections, and \dropin does not need to learn any parameters.
%Furthermore, the skip connection experiments in their paper are with  shallower networks compared to those considered here.

Romero \etal \cite{romero2014fitnets} suggest training a thin, deep student network (called a \textit{fitnet}) from a larger but shallower teacher network.  
The authors accomplish this by utilizing the output of the teacher's hidden layers as a hint for the student's hidden layers.

Srivastava \etal \cite{srivastava2015highway, srivastava2015training} propose a new architecture, which they named \textit{Highway Networks}, where the output of a layer's neuron contains a combination of the input and the output. 
Highway networks use carry gates inspired by long short-term memory (LSTM) recurrent neural networks (RNNs) to regulate how much of the input is carried to the next layer.  
The authors %state that network depth is crucial for the recent success of neural networks and 
demonstrate that their structure permits training networks of hundreds of layers (up to 900 layers) \cite{srivastava2015highway, srivastava2015training}. 
These new parameters are learned along with the other parameters of the network.   
Zhang \etal \cite{Zhang2015highway} applied highway networks to LSTM recurrent neural networks.
\dropin is a simpler approach than highway networks as it does not contain gate parameters that need to be learned.

Breuel \cite{breuel2015possible} discusses a dynamic network that he describes as a biologically plausible ``reconfigurable'' network.
In this network different units are weighted dynamically to produce different configurations.  This allows a single network to perform multiple tasks.
%In other words, it is as though a network is composed of different classifiers, each implemented by a different configuration.  Each configuration is created by a control mechanism that sets an additional group of parameters.
\dropin represents a different type of dynamic network that grows during training rather than reconfigures for each task.

\subsection{Regularization during training}
The well-known dropout \cite{hinton2012improving, srivastava2014dropout} method is an effective means to improve the training  of deep neural networks.   
During training dropout randomly zeros a neuron's output activation with a probability $p$, called the \textit{dropout ratio},  so that the network cannot rely on a particular configuration.
This reduces overfitting to the training data and the resulting network is more robust and better generalizes to unseen data.  
While dropout ``samples from an exponential number of different `thinned' networks'' \cite{srivastava2014dropout}, \dropin samples from an exponential number of different thinner and shallower sub-networks.
Like dropout, \dropin randomly changes the configuration so that the network cannot rely on a particular configuration. 

Baldi and Sadowski \cite{baldi2013understanding} provide a theoretical basis for understanding dropout,  demonstrating that dropout regulates the training and prevents overfitting by approximating an average of a  large ensemble of networks.  
A similar theoretical understanding (and benefits) can also apply to \dropinNS.

%Wan \etal \cite{wan2013regularization} suggest dropconnect, which randomly sets a subset of weights to zero (in contrast to randomly setting a subset of activations to zero, as is done by dropout).
%A recent paper by Wu \etal \cite{wu2015flip} suggests an interesting modification to dropout that they call split dropout.  In each iteration, instead of zeroing activations or weights, they create two random, thinned sub-networks each iteration and train each separately.

%-------------------------------------------------------------------------

\begin{figure}[tb]
\begin{center}
%\fbox{\rule{0pt}{2in} \rule{0.9\linewidth}{0pt}}
   \includegraphics[width=0.9\linewidth]{diagram.png}
\end{center}
  \vspace{-10pt}
   \caption{Diagram of traditional vs \dropin training method.  The \dropin method sends activations from Layer $ {\ell} $ to Layer $ {\ell+1} $ with a ratio $p$ and from Layer $ {\ell-1} $ to Layer $ {\ell+1}$ (thus skipping Layer $\ell$) with a ratio $q=1-p$.
}
\label{fig:diagram}
  \vspace{-10pt}
\end{figure}

%-------------------------------------------------------------------------

\section{\dropin method}
In this section we provide a mathematical basis for \dropin as well as some implementation details.

\subsection{Model description}
\label{sec:model}
There are two modes of running \dropinNS: first to gradually include skipped layers, which we refer to as \textit{gradual \dropinNS}, and second as a regularizer, which we named \textit{regularizing \dropinNS}.
Figure \ref{fig:diagram} provides a visual reference as to how the \dropin unit works.

Gradual \dropin initially passes on only the activations from the previous layer, effectively skipping the new layers.  
For each iteration number, $\tau$, the ratio $ p $ is computed as $ p = \tau / d$ for \dropin length $d$, which is the number of iterations over which $q = 1 - p$ reduces from 1 to 0. 
Then the number of activations copied from layer $ {\ell-1} $ drops as  $ q \times n = (1 - p) \times n $, where $n$ is the total number of activations in the layer ${\ell-1}$.  
The remaining activations are accepted from the new layer $ {\ell} $ and backpropagation trains the weights of these newly added units.

For regularizing \dropinNS, the \dropin probability ratio $p$ is set to a static value in $[0,1]$.
In this case, \dropin works analogously with dropout but instead of setting values to zero, they are set to the activations of a previous layer (e.g., $ {\ell-1} $).
The choice of which activations come from which layer is done in an evolving random fashion each iteration.

We follow the notation in the dropout paper \cite{srivastava2014dropout} to show this more formally.
Namely, we start with a neural network composed of some number of layers, $L$, where $ \ell \in [1, 2, \dots, L] $ is the layer index.
Also, $ \mathbf{y}^{(\ell)} $ represents the vector of outputs from layer $ {\ell} $ and is the input to the next layer $ {\ell+1} $.  Let $ \mathbf{x} $ be the data input to the first layer. 
In addition, $ \mathbf{W}^{(\ell)} $ and $ \mathbf{b}^{(\ell)} $ are the weights and biases at layer $ \ell $.  
To allow us to track the evolving nature of the network, we include the training iteration number, $\tau$, and the layer's unit index number, $\lambda^{(\ell)}$.
% as such, $y^{(\ell)}(\tau, \lambda)$.

The first equation for gradual \dropin is a vector of zeros then ones, which is designated as: 
\begin{eqnarray}
\mathbf{r}^{(\ell)}(\tau,\lambda^{(\ell)}) =\begin{cases} 0 &\lambda^{(\ell)}< q \times n \\
1 & \mbox{otherwise}.
\end{cases}\end{eqnarray}
%The size of  $ \mathbf{r}^{(\ell)} $ is the number of activations output from either the previous and the new layer.  %In order to handle situations where the number of activations is different between  the previous and new layers, we implemented a Resize layer in Caffe that can be used to modify the number of output activations.
%The Resize layer will be discussed in more detail later.
%As described above, initially  $ \mathbf{r}^{(\ell)} $ is a vector of all zeros, then the last $  size[ \mathbf{r}^{(\ell)}] \times (iteration / dropin\_length) $ are set to one.
For regularizing \dropinNS, the  equation for $ \mathbf{r}^{(\ell)}(\tau, \lambda^{(\ell)})$ with a probability ratio $ p $ is:
\begin{equation}
\mathbf{r}^{(l)}(\tau,\cdot) \sim Bernoulli(p), 
\end{equation}
i.e.,  a 0-1 vector where each value is distributed as a Bernoulli random variable with probability $p$.  

Once $ \mathbf{r} $  is set, the remaining equations (dropping $\tau$ and $\lambda^{(\ell)}$ for simplicity) are the same for both modes -- namely for layer $ {\ell+1}$:
\begin{equation}
\mathbf{\tilde{y}}^{(\ell)} = \mathbf{r}^{(\ell)} \times \mathbf{y}^{(\ell)}  \\
\end{equation}
\begin{equation}
z^{(\ell+1)}_i  = \mathbf{w}^{(\ell+1)}_i \mathbf{\tilde{y}}^{(\ell)} + b_i^{(\ell+1)} \\
\end{equation}
\begin{equation}
\mathbf{y}^{(\ell+1)} = f ( z_i^{(\ell)} ) + ( 1 - \mathbf{r}^{(\ell)} )  \mathbf{y}^{(\hat{\ell})},
\end{equation}
where $ \hat{\ell} $ is any layer less than layer $ {\ell+1}$.
These equations are similar to those for dropout, except instead of some of the outputs being zero, they are set to the values from a previous layer, $ \mathbf{y}^{(\hat{\ell})} $.


\subsection{Implementation}
\label{sec:code}

We implemented our method in Caffe \cite{Caffe14} by creating a new layer called \dropinNS.
The parameters for the \dropin layer include a $dropin\_ratio$, $ q = 1 - p$ (Figure \ref{fig:diagram}), and a $dropin\_length$, $d$, as described in Section \ref{sec:model}.

\dropin requires that the size of both the new layer and the previous layer be the same.
Hence, we also implemented a Resize layer to allow reshaping a layer's output to a user-specified size.
The Resize layer modifies its input, which is $ \mathbf{y}^{(\hat{\ell})},$ into a user-specified height, width, and number of channels/filters. 
%The parameters are $num$, $channels$, $height$, $width$, and $back$, where $num$ is the batch size, $channels$ is the number of filters, $height$ and $width$ are the height and width of the filters respectively, and $back$ is a boolean indicating if the resize is for back propagation.
%Since Caffe treats data as blobs, the actual method which performs the resizing is is added to the Blob class in Caffe. 
%The bulk of the processing takes place in the actual Blob resize method. 
%The Resize layer copies the input layer, calls the blob resize method, and returns the resized blob as the output.  
The Resize layer allows \dropin to work with any two layers, even when the sizes of $ \mathbf{y}^{(\ell)}$ and $ \mathbf{y}^{(\hat{\ell})} $ are different.

%-----------------------------------------------------------------------

\section{Experiments}
\label{sec:experiments}

The purpose of this section is to demonstrate the effectiveness of \dropin on several standard datasets but with  architectures that are not trainable with standard methods.
No attempt was made to optimize the architecture or hyper-parameters for higher accuracy because our main objective was to show that a deep architecture that will not converge without \dropinNS, will converge with it.
However, the results in Sections  \ref{sec:alexnet} and \ref{sec:vgg}  also demonstrate an increase in accuracy by using a deeper network for Imagenet.

%In the followgin subsections below, \dropin is used for training CNN architectures with MNIST,  CIFAR-10, and ImageNet datasets.
%We found that in all cases \dropin permitted training an otherwise untrainable architecture.
All of the following experiments were run with Caffe (downloaded August 31, 2015) using CUDA 7.0 and Nvidia's CuDNN.  
%For training larger networks, we utilized the multi-gpu implementation of Caffe.  
These experiments were run on a 64 node cluster with 8 Nvidia Titan Black GPUs, 128 GB memory, and dual Intel Xenon E5-2620 v2 CPUs per node.  

The following subsections depict, in table form, the structure of several networks.  We use the naming convention \{layer type\}\{layer number\}-\{number of outputs\}(filter size).  
For example, conv1\_2-32$(5\times 5)$ represents a convolutional layer numbered 1\_2 with 32 outputs and filters sized $5\times 5$.  
\dropin layers are denoted as dropin $(\ell + (\ell + 1))$, as depicted in Figure \ref{fig:diagram}.

In Section \ref{sec:mnist} we show that very deep networks are trainable when using gradual \dropin on expanded LeNet with MNIST data.  In Section \ref{sec:cifar} we show the effect of \dropin length on training accuracy for expanded CIFAR-10 network and that a small performance gain is possible with added layers.
In Section \ref{sec:alexnet} we show that an expanded AlexNet architecture increases accuracy and is trainable only with gradual \dropin.  
In Section \ref{sec:vgg} the VGG16 network is trained using gradual \dropin without the need to transfer weights from a shallower network.  
%-----------------------------------------------------------------------

\begin{table}[htb]
\begin{center}
  \begin{tabular}{| c | c |}
    \hline
      LeNet & LeNet(2N) {\color{red}+ \dropin} \\ \hline
    
     \multicolumn{2}{|c|}{data $(28\times 28 )$} \\ \hline
     conv1\_1-20$(5\times 5)$ & conv1\_1-20$(5\times 5)$ \\ 
%$\mbox{conv}1_1$-20(5$\times$5) & conv1\_1-20$(5\times 5)$ \\ 
        & conv1\_2-20$(3\times 3)$ \\ 
       & {\color{red}dropin (1\_1 + 1\_2)} \\
        & conv1\_3-20$(3\times 3)$ \\ 
       & {\color{red}dropin (1\_2 + 1\_3)} \\ 
         & $\vdots$ \\ 
        & conv1\_N-20$(3\times 3)$ \\ 
       & {\color{red}dropin (1\_(N-1) + 1\_N)} \\ \hline
	\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline

     conv2\_1-50$(5\times 5)$ & conv2\_1-50$(5\times 5)$ \\ 
       & conv2\_2-50$(3\times 3)$ \\ 
      & {\color{red}dropin (2\_1 + 2\_2)} \\
      & conv2\_3-50$(3\times 3)$ \\ 
      & {\color{red}dropin (2\_2 + 2\_3)} \\ 
       & $\vdots$ \\ 
      & conv2\_N-50$(3\times 3)$ \\ 
      & {\color{red}dropin (2\_(N-1) + 2\_N)} \\ \hline
\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline
\multicolumn{2}{|c|}{fc3-500} \\ \hline
\multicolumn{2}{|c|}{fc4-10} \\ \hline
\multicolumn{2}{|c|}{soft-max} \\ \hline
  \end{tabular}
  \caption{Network architecture for LeNet and LeNet(2N)+ \dropinNS.  }
  \label{tab:lenet_N}
\end{center}
  \vspace{-20pt}
\end{table}

\begin{figure}[tbh]
\begin{center}
%\fbox{\rule{0pt}{2in} \rule{0.9\linewidth}{0pt}}
%   \includegraphics[width=0.9\linewidth]{lenet10_dropin.png}
   \includegraphics[width=1.0\linewidth]{mnist1.png}
\end{center}
  \vspace{-10pt}
   \caption{Classification accuracy while training LeNet(10) + \dropin architecture with MNIST data. Curves represent different \dropin lengths, $d$.  (Best viewed in color)  
}
\label{fig:lenet_10}
  \vspace{-10pt}
\end{figure}

\begin{figure}[tbh]
\begin{center}
\begin{subfigure}[b]{0.5\textwidth}
        \includegraphics[width=\textwidth]{mnist2.png}
        %\caption{\dropin length of 2,500}
    \end{subfigure}\\
    \begin{subfigure}[b]{0.5\textwidth}
        \includegraphics[width=\textwidth]{mnist3.png}
        %\caption{\dropin length of 7,500}
    \end{subfigure}
\end{center}
 \vspace{-10pt}
   \caption{Classification accuracy while training LeNet(2N) + \dropinNS, for $N=5,15,25$ with MNIST data. Curves represent different network depths. (Best viewed in color)  
}
\label{fig:lenet_droplens}
  \vspace{-10pt}
\end{figure}


%-----------------------------------------------------------------------

\subsection{MNIST} \label{sec:mnist}
This dataset consists of 70,000 grey-scale images with a resolution of 28x28\footnote{\url{http://yann.lecun.com/exdb/mnist/}}.  
Of these, 60,000 are for training and 10,000 are for testing.  
There are ten classes, each a different handwritten digit from zero to nine, with 7,000 images per class.  

The standard network architecture for the classification of MNIST, provided in the Caffe package, is the 4-layer LeNet consisting of 2 convolutional/max-pooling layers followed by 2 fully-connected layers (see the first column of Table \ref{tab:lenet_N} for details).  
Inspired by the work in \cite{srivastava2015training}, we increased the number of convolutional layers from two to 2N, which we denote as LeNet(2N).  
These added layers (as seen in the second column of Table \ref{tab:lenet_N}, minus the \dropin layers shown in red) learned a $3\times 3$ convolution filter but did not change the size of the outputs.  
We then added \dropin layers between each of the convolutional layers (as seen in the second column of Table \ref{tab:lenet_N}) and called this network LeNet(2N) + \dropinNS.

We first looked at $N=5$ and created LeNet(10) and LeNet(10) + \dropin architectures.   LeNet(10) did not converge in the standard training time of 10,000 iterations given multiple realizations of the training process.  
However, utilizing \dropin units we were able to have LeNet(2N) + \dropin  converge 10,000 iterations with the same hyper-parameters.  
In Figure \ref{fig:lenet_10} we show results for several different \dropin lengths for this network.  These different lengths indicate the robustness of the \dropin length for simpler networks and that, in general, shorter \dropin lengths provide marginally better results.
We note for this case that the added layers do not increase the overall accuracy of the network, as the MNIST data is quite simple compared with other classification tasks; the added layers do not provide any extra differentiation power.  


We now look at how the number of layers affects the training with \dropinNS.  
In Figure \ref{fig:lenet_droplens} there are two different plots, one with \dropin length of 2,500 iterations and the other with \dropin length of 7,500 iterations.  For each plot we present three different networks with 10, 30, and 50, convolutional layers (equating to N=5, 15, 25).  
For both \dropin lengths and all three network depths, the gradual \dropin method allowed the networks to converge.  
The deeper networks require a greater number of iterations to reach the same level of accuracy as the shallower networks, which is to be expected as they have a greater number of weights to train.  We also see that networks converge  more quickly with the shorter \dropin length,  indicating that shorter \dropin lengths are desirable.  




%-----------------------------------------------------------------------


\begin{table}[htb]
\begin{center}
  \begin{tabular}{| c | c |}
    \hline
     CIFAR-10 &  CIFAR-10(11 layers) {\color{red}+ \dropin}   \\ \hline
    
     \multicolumn{2}{|c|}{data $(32\times32\times3)$} \\ \hline
     conv1-32$(5\times 5)$ & conv1\_1-32$(5\times 5)$ + LRN \\ 
     maxpool$(2\times2)$ & conv1\_2-32$(5\times 5)$ + LRN\\ 
     LRN & {\color{red}dropin (1\_1 + 1\_2)} \\ \hline
     conv2-32$(5\times 5)$ & conv2\_1-32$(5\times 5)$ + LRN\\ 
     maxpool$(2\times2)$ & conv2\_2-32$(5\times 5)$ + LRN\\ 
     LRN    &					{\color{red}dropin (2\_1 + 2\_2)} \\ \hline
     & conv3\_1-32$(5\times 5)$ + LRN\\ 
     & conv3\_2-32$(5\times 5)$ + LRN\\ 
     &					{\color{red}dropin (3\_1 + 3\_2)} \\ \hline
     & conv4\_1-32$(5\times 5)$ + LRN\\ 
     & conv4\_2-32$(5\times 5)$ + LRN\\ 
     &					{\color{red}dropin (4\_1 + 4\_2)} \\ \hline
     & conv5\_1-32$(5\times 5)$ + LRN\\ 
     & conv5\_2-32$(5\times 5)$ + LRN\\ 
     &					{\color{red}dropin (5\_1 + 5\_2)} \\ \hline
%\multicolumn{2}{|c|}{maxpool(2x2) + LocalNorm} \\ \hline
     conv3-64$(3\times 3)$ & conv6\_1-64$(3\times 3)$ \\  \hline
\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline
\multicolumn{2}{|c|}{fc-10} \\ \hline
\multicolumn{2}{|c|}{soft-max} \\ \hline
\multicolumn{2}{|c|}{accuracy} \\ \hline
  \end{tabular}
  \caption{CIFAR-10 11-layer architecture, including \dropin units.}
  \label{tab:cifarArch}
\end{center}
  \vspace{-25pt}
\end{table}


\begin{figure}[tb]
\begin{center}
   \includegraphics[width=1.0\linewidth]{cifar-dropin-lengths.png}
\end{center}
  \vspace{-10pt}
   \caption{Test data classification accuracy while training the 11-layer CIFAR-10 architecture with \dropinNS. The curves show classification accuracies for different dropin\_lengths, $d$. (Best viewed in color)  
}
\label{fig:cifarDropinLen}
  \vspace{-5pt}
\end{figure}

%-------------------------------------------------------------------------

\begin{table}[tb]
\begin{center}
  \begin{tabular}{| c | c | c |}
    \hline
    Architecture & dropin\_length & Accuracy (\%) \\ \hline \hline
   3-layer net &     & 81.4 \\ \hline
   11-layer net & 8,000  & 81.7 \\ \hline
   11-layer net & 16,000  & \textbf{82.3} \\ \hline
   11-layer net & 24,000  & \textbf{82.3} \\ \hline
  \end{tabular}
  \caption{Final accuracy (average of last three values) results for the CIFAR-10 dataset on test data at the end of the training.  Comparison of \dropin and dropin\_lengths. }
  \label{tab:cifarLengths}
\end{center}
  \vspace{-20pt}
\end{table}



%-----------------------------------------------------------------------

\subsection{CIFAR-10} \label{sec:cifar}

This dataset consists of 60,000 color images with a resolution of 32x32.
Of these, 50,000 are for training and 10,000 are for testing.
There are ten classes with 6,000 images per class. 

The Caffe \cite{Caffe14} website provides the architecture and hyper-parameter settings as part of the CIFAR-10 tutorial\footnote{\url{http://caffe.berkeleyvision.org/gathered/examples/cifar10.html}}.
The three convolutional layer architecture trains quickly and attains good accuracies.
The convolutional layers were replicated to obtain an 11-layer model, which corresponds to the depth of one of the CIFAR-10 models in the experiments for highway networks \cite{srivastava2015training}. 
The detailed architectures are compared in Table \ref{tab:cifarArch}.
As shown in the table, the sizes of each of the layers entering the \dropin layer were kept the same for simplicity.
For every convolutional layer, the weight initialization was Gaussian with standard deviation of 0.01 and the bias initialization was constant, set to 0.
Each convolutional layer was followed by a rectified linear unit and local normalization.
%The parameters for every local normalization were local size = $3$, alpha = $5 \times 10^{-5}$, beta = $0.75$, and norm region = WITHIN CHANNEL.
The length of the training, the learning rates, and schedule were modified to run over 32,000 iterations.
This modification trained satisfactorily and provided a reasonable comparison.

Numerous attempts at training this 11-layer network without the \dropin layers failed to converge.
Similar attempts to train this network with the \dropin layers did successfully converge, which is a primary result of this study.

Experiments were performed varying the \dropin length.
Figure \ref{fig:cifarDropinLen} shows the accuracy curves for $ dropin\_length = 8,000, 16,000, 24,000$,  and Table \ref{tab:cifarLengths} compares the final accuracies.
The final accuracies show a marginal improvement for longer versus shorter lengths but for CIFAR-10 the results are relatively independent of the length value.
Furthermore, the final accuracies from the 11-layer architecture are less than 1\% better than the original 3-layer architecture, which implies that for the CIFAR-10 dataset, the deeper networker  provides  only marginal improvement.



%-------------------------------------------------------------------------

\begin{table}[htb]
\begin{center}
  \begin{tabular}{| c | c |}
    \hline
     AlexNet  & AlexNet (13 layers) {\color{red}+ \dropin} \\ \hline
    
     \multicolumn{2}{|c|}{data $(227\times227\times3)$} \\ \hline
     conv1\_1-96$(11\times 11)$ & conv1\_1-96$(11\times 11)$ \\ 
      & conv1\_2-96$(11\times 11)$ \\ 
     &					{\color{red}dropin (1\_1 + 1\_2)} \\ \hline
	\multicolumn{2}{|c|}{maxpool$(2\times2)$ + LocalNorm} \\ \hline
     conv2\_1-256$(5\times 5)$ & conv2\_1-256$(5\times 5)$ \\ 
      & conv2\_2-256$(5\times 5)$ \\ 
     &					{\color{red}dropin (2\_1 + 2\_2)} \\ \hline
\multicolumn{2}{|c|}{maxpool$(2\times2)$ + LocalNorm} \\ \hline
     conv3\_1-384$(3\times 3)$ & conv3\_1-384$(3\times 3)$ \\ 
      & conv3\_2-384$(3\times 3)$ \\ 
     &					{\color{red}dropin (3\_1 + 3\_2)} \\ \hline
%\multicolumn{3}{|c|}{maxpool(2x2)} \\ \hline
     conv4\_1-384$(3\times 3)$ & conv4\_1-384$(3\times 3)$ \\ 
      & conv4\_2-384$(3\times 3)$ \\
     &					{\color{red}dropin (4\_1 + 4\_2)} \\ \hline
%\multicolumn{2}{|c|}{maxpool(2x2)} \\ \hline
     conv5\_1-256$(3\times 3)$ & conv5\_1-256$(3\times 3)$ \\ 
      & conv5\_2-256$(3\times 3)$ \\
     &					{\color{red}dropin (5\_1 + 5\_2)} \\ \hline
\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline
\multicolumn{2}{|c|}{fc6-4096} \\ \hline
\multicolumn{2}{|c|}{fc7-4096} \\ \hline
\multicolumn{2}{|c|}{fc8-1000} \\ \hline
\multicolumn{2}{|c|}{soft-max} \\ \hline
  \end{tabular}
  \caption{Network architecture for AlexNet and modified version of AlexNet, AlexNet (13 layers) + \dropin.  }
  \label{tab:alexnet13}
\end{center}
  \vspace{-15pt}
\end{table}



\begin{figure}[htb]
\begin{center}
%\fbox{\rule{0pt}{2in} \rule{0.9\linewidth}{0pt}}
   \includegraphics[width=.901\linewidth]{dropin_Alex_lengths.png}
\end{center}
  \vspace{-15pt}
   \caption{Comparison of various \dropin lengths, $d$.  Validation data classification accuracy while training the AlexNet (13 layers) + \dropin architecture with ImageNet data. (Best viewed in color) 
}
\label{fig:AlexLengths}
  \vspace{-5pt}
\end{figure}


\begin{table}[tb]
\begin{center}
  \begin{tabular}{| c | c | c |}
    \hline
    Architecture & dropin\_length & Accuracy (\%) \\ \hline \hline
   AlexNet &     & 58.0 \\ \hline
   13 layers + \dropin & 25,000  & \textbf{62.2} \\ \hline
   13 layers + \dropin & 75,000  & 62.1 \\ \hline
   13 layers + \dropin & 150,000  & 60.8 \\ \hline
   13 layers + \dropin & 300,000  & 59.3 \\ \hline
  \end{tabular}
  \caption{Comparison of \dropin and dropin\_lengths, $d$. The table shows final accuracy (average of last three values) results for the ImageNet dataset on validation data at the end of the training.}
  \label{tab:dropinLengths}
\end{center}
  \vspace{-20pt}
\end{table}

%-----------------------------------------------------------------------

\subsection{ImageNet / AlexNet}
\label{sec:alexnet}

ImageNet\footnote{\url{www.image-net.org/}} \cite{Imagenet15} is a large image database based on the nouns in  WordNet.
This image database, used for the ImageNet Large Scale Visual Recognition Challenge, is commonly used as a basis of comparison in the deep learning literature.
The database contains 1.2 million training and 50,000 testing images covering 1,000 categories.

The Caffe website provides the architecture and hyper-parameter files for a slightly modified AlexNet. %\footnote{\url{caffe.berkeleyvision.org/gathered/examples/imagenet.html}}.
We downloaded the architecture and hyper-parameter files from the website and we expanded the architecture from 8 layers to 13 layers by duplicating each of the convolutional layers, which is shown (minus the \dropin layers shown in red) in columns 1 and 2, respectively, of Table \ref{tab:alexnet13}.
The AlexNet (13 layers) + \dropin includes a \dropin layer between every duplicated layer used to create AlexNet (13 layers).
Multiple attempts at training the AlexNet (13 layers) architecture in the conventional manner did not converge.
%In the training results reported in this section, all weights were initialized the same so as to avoid differences due to different random initializations.
In the tests with the expanded architecture, the hyper-parameters were kept the same as provided by the Caffe website (even though our experiments with \dropin indicate that tuning them could improve the results).
%In particular, a better learning rate and schedule is likely to improve the results but we left this as future work.

Experiments were run varying the \dropin hyper-parameter \textit{dropin\_length}.
Table \ref{tab:dropinLengths} shows final accuracy results after training for 450,000 iterations with a range of lengths. 
Figure \ref{fig:AlexLengths} compares the accuracy during training of these experiments.
In contrast to the results with CIFAR-10, the \dropin length makes a difference with ImageNet.
We believe that this is because the deeper architecture increases the classification accuracy for larger datasets, hence  the improvement with smaller \dropin lengths is more prominent.

From Figure \ref{fig:AlexLengths} and Table \ref{tab:dropinLengths},  we can conclude that shorter lengths are better than the longer ones.
If the length is less than the first scheduled drop in the learning rate at iteration 100,000, then the network is better trained.
However, the difference between $dropin\_length = 75,000$ and 25,000 is negligible implying that lengths less than the first scheduled learning rate drop are equivalent.
%The curve for $dropin\_length = 75000$ in Figure \ref{fig:AlexLengths} shows a significant improvement in accuracy until 75,000 and after iteration 75,000 the training curve proceeds like a typical training curve.


%-------------------------------------------------------------------------

%\begin{table}[htb]
%\begin{center}
%  \begin{tabular}{| c | c | c |}
%    \hline
%    VGG8 & VGG13 & VGG16 \\ \hline
%    
%     \multicolumn{3}{|c|}{data (224x224 RGB)} \\ \hline
%     conv1\_1-64$(3\times 3)$& conv1\_1-64$(3\times 3)$ & conv1\_1-64$(3\times 3)$ \\ 
%     & conv1\_2-64$(3\times 3)$ & conv1\_2-64$(3\times 3)$ \\ \hline
%	\multicolumn{3}{|c|}{maxpool(2x2)} \\ \hline
%     conv2\_1-128$(3\times 3)$ & conv2\_1-128$(3\times 3)$ & conv2\_1-128$(3\times 3)$ \\ 
%     & conv2\_2-128$(3\times 3)$ & conv2\_2-128$(3\times 3)$ \\ \hline
%\multicolumn{3}{|c|}{maxpool(2x2)} \\ \hline
%     conv3\_1-256$(3\times 3)$ & conv3\_1-256$(3\times 3)$ & conv3\_1-256$(3\times 3)$ \\ 
%     & conv3\_2-256$(3\times 3)$ & conv3\_2-256$(3\times 3)$ \\
%     &			& conv3\_3$(3\times3)$ \\ \hline
%\multicolumn{3}{|c|}{maxpool(2x2)} \\ \hline
%     conv4\_1-512$(3\times 3)$ & conv4\_1-512$(3\times 3)$ & conv4\_1-512$(3\times 3)$ \\ 
%     & 					   conv4\_2-512$(3\times 3)$ & conv4\_2-512$(3\times 3)$ \\
%     &						& 							conv4\_3-512$(3\times 3)$ \\ \hline
%\multicolumn{3}{|c|}{maxpool(2x2)} \\ \hline
%     conv5\_1-512$(3\times 3)$ & conv5\_1-512$(3\times 3)$ & conv5\_1-512$(3\times 3)$ \\ 
%     &						  conv5\_2-512$(3\times 3)$ & conv5\_2-512$(3\times 3)$ \\
%     &			& conv5\_3-512$(3\times 3)$ \\ \hline
%\multicolumn{3}{|c|}{maxpool(2x2)} \\ \hline
%\multicolumn{3}{|c|}{FC-4096} \\ \hline
%\multicolumn{3}{|c|}{FC-4096} \\ \hline
%\multicolumn{3}{|c|}{FC-1000} \\ \hline
%\multicolumn{3}{|c|}{soft-max} \\ \hline
%    
%  \end{tabular}
%  \caption{Network architectures for VGG8, VGG13, and VGG16.  The layers follow the naming convention, \{type\}\{layer number\}\{\_sublayer number\}-\{number of outputs\}\{filter size\}.  See the text for additional settings.}
%  \label{tab:vgg}
%\end{center}
%\end{table}

%\begin{table}[htb]
%  \vspace{-10pt}
%\begin{center}
%  \begin{tabular}{| c | c |}
%    \hline
%    VGG8 &  VGG16 \\ \hline
%    
%     \multicolumn{2}{|c|}{data (224x224 RGB)} \\ \hline
%     conv1\_1-64$(3\times 3)$& conv1\_1-64$(3\times 3)$ \\ 
%     &  conv1\_2-64$(3\times 3)$ \\ \hline
%	\multicolumn{2}{|c|}{maxpool(2x2)} \\ \hline
%     conv2\_1-128$(3\times 3)$ & conv2\_1-128$(3\times 3)$ \\ 
%     &   conv2\_2-128$(3\times 3)$ \\ \hline
%\multicolumn{2}{|c|}{maxpool(2x2)} \\ \hline
%     conv3\_1-256$(3\times 3)$ & conv3\_1-256$(3\times 3)$ \\ 
%     &  conv3\_2-256$(3\times 3)$ \\
%     &			 conv3\_3$(3\times3)$ \\ \hline
%\multicolumn{2}{|c|}{maxpool(2x2)} \\ \hline
%     conv4\_1-512$(3\times 3)$ & conv4\_1-512$(3\times 3)$ \\ 
%     & 					     conv4\_2-512$(3\times 3)$ \\
%     &						 							conv4\_3-512$(3\times 3)$ \\ \hline
%\multicolumn{2}{|c|}{maxpool(2x2)} \\ \hline
%     conv5\_1-512$(3\times 3)$ & conv5\_1-512$(3\times 3)$ \\ 
%     &						   conv5\_2-512$(3\times 3)$ \\
%     &			 conv5\_3-512$(3\times 3)$ \\ \hline
%\multicolumn{2}{|c|}{maxpool(2x2)} \\ \hline
%\multicolumn{2}{|c|}{FC-4096} \\ \hline
%\multicolumn{2}{|c|}{FC-4096} \\ \hline
%\multicolumn{2}{|c|}{FC-1000} \\ \hline
%\multicolumn{2}{|c|}{soft-max} \\ \hline
%    
%  \end{tabular}
%  \caption{Network architectures for VGG8, VGG13, and VGG16.  The layers follow the naming convention, \{type\}\{layer number\}\{\_sublayer number\}-\{number of outputs\}\{filter size\}.  See the text for additional settings.}
%  \label{tab:vgg}
%\end{center}
%  \vspace{-20pt}
%\end{table}
\begin{table}[htb]
  \vspace{-5pt}
\begin{center}
  \begin{tabular}{| c | c |}
    \hline
     VGG8 & VGG16 {\color{red}+ DropIn} \\ \hline
    
     \multicolumn{2}{|c|}{data $(224\times224\times3)$} \\ \hline
      conv1\_1-64$(3\times 3)$ & conv1\_1-64$(3\times 3)$ \\ 
      								& conv1\_2-64$(3\times 3)$ \\ 
      								& {\color{red}dropin (1\_1 + 1\_2)}\\ \hline
	\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline
      conv2\_1-128$(3\times 3)$ & conv2\_1-128$(3\times 3)$ \\ 
      & conv2\_2-128$(3\times 3)$ \\  
      & {\color{red}dropin (2\_1 + 2\_2)}\\ \hline
\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline
     conv3\_1-256$(3\times 3)$ & conv3\_1-256$(3\times 3)$ \\ 
     &conv3\_2-256$(3\times 3)$ \\
     &  {\color{red}dropin (3\_1 + 3\_2)}\\ 
     &			 conv3\_3-256$(3\times 3)$ \\
     &		  {\color{red}dropin (3\_2 + 3\_3)}\\ \hline 
\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline
      conv4\_1-512$(3\times 3)$& conv4\_1-512$(3\times 3)$ \\ 
      &conv4\_2-512$(3\times 3)$ \\
      & {\color{red}dropin (4\_1 + 4\_2)}\\ 
     &			 conv4\_3-512$(3\times 3)$ \\ 
     &  {\color{red}dropin (4\_2 + 4\_3)}\\ \hline
\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline
     conv5\_1-512$(3\times 3)$ & conv5\_1-512$(3\times 3)$ \\ 
     &conv5\_2-512$(3\times 3)$ \\
 &{\color{red}dropin (5\_1 + 5\_2)}\\ 
  &   			 conv5\_3-512$(3\times 3)$ \\ 
   &  			      {\color{red} dropin (5\_2 + 5\_3)}\\ \hline
\multicolumn{2}{|c|}{maxpool$(2\times2)$} \\ \hline
\multicolumn{2}{|c|}{fc6-4096} \\ \hline
\multicolumn{2}{|c|}{fc7-4096} \\ \hline
\multicolumn{2}{|c|}{fc8-1000} \\ \hline
\multicolumn{2}{|c|}{soft-max} \\ \hline
    
  \end{tabular}
  \caption{Network architectures for VGG8 and VGG16 + \dropinNS.  See the text for additional settings.}
  \label{tab:vgg_dropin}
\end{center}
  \vspace{-15pt}
\end{table}



\begin{figure}[]
\begin{center}
%\fbox{\rule{0pt}{2in} \rule{0.9\linewidth}{0pt}}
   \includegraphics[width=1.0\linewidth]{VGG8_16.png}
\end{center}
  \vspace{-15pt}
   \caption{Validation data classification accuracy while training the VGG16 + \dropin architecture with ImageNet data. (Best viewed in color)
}
\label{fig:vgg_plot}
  \vspace{-10pt}
\end{figure}

%-------------------------------------------------------------------------


\subsection{ImageNet / VGG}
\label{sec:vgg}
VGG$n$, a set of networks created by the Visual Geometry Group \cite{simonyan2014very}, won second place in the image classification category of the 2014 ImageNet contest.  These networks, trained on the same database as the Alexnet architecture discussed in Section \ref{sec:alexnet}, contained $ n=11,13,16,\mbox{ or }19$ layers.  In Table \ref{tab:vgg_dropin} we see the VGG16 (minus the \dropin layers shown in red) architecture alongside what we will refer to as VGG8 (not contained in the original paper).
All convolutional layers have a stride and padding of 1 and maxpooling layers have a stride of 2. 
In their paper, the authors describe the difficulty of training these deep networks and utilized a weight transfer method to enable the network to converge during training \cite{simonyan2014very}.

%\begin{quote} The initialisation of the network weights is important, since bad initialisation can stall learning due to the instability of gradient in deep nets. To circumvent this problem, we began with training the configuration A (Table 1) [VGG13], shallow enough to be trained with random initialisation. Then, when training deeper architectures, we initialised the first four convolutional layers and the last three fullyconnected layers with the layers of net A (the intermediate layers were initialised randomly).\end{quote}

While it is possible to train a deep neural network by first training a shallow network and using those weights to initialize the deeper network, we believe that in addition to being easier, training the full network with all the layers in place leads to a better trained network.  This is supported by research on feature visualization, such as in Zeiler and Fergus \cite{zeiler2014visualizing}, where they demonstrate that higher layers have more abstract representations.
Training in place means that the learned representations will conform well to the representation at a given layer, while training a shallow network and initializing the weights of a deeper network might not.
%Our future work includes comparing using \dropin to initializing the weights from training a separate shallow network.

Instead of training smaller networks, we propose to use our gradual DropIn method.  
For our studies, we utilized the VGG16 prototxt file referenced on the Caffe website\footnote{\url{https://gist.github.com/ksimonyan/211839e770f7b538e2d8\#file-vgg_ilsvrc_16_layers_deploy-prototxt}} 
and set up the solver file with the appropriate parameters from the authors' paper.  Using traditional training methods, we were only able to train the VGG8 architecture;  the VGG16 failed to begin converging for multiple realizations.  Using VGG8 as a template,  we augment VGG16 with \dropin layers to create VGG16 + \dropin (see Table \ref{tab:vgg_dropin}).  

Based on the evidence presented in Section \ref{sec:alexnet}, we choose to test VGG16 with a \dropin length of 60,000. We found that other lengths (100,000, 150,000, and 200,000) began to converge as well but with limited time and resources, we chose to report only this length for this paper.
The results of training VGG16 + \dropin are shown in Figure \ref{fig:vgg_plot} alongside VGG8.  We see that with gradual \dropin the difficult to train VGG16 network does converge.  Here we see the real power of the gradual \dropin method; without training an additional shallower network we are able to directly train VGG16,  thus saving effort for the practitioner. % More experimentation is required to tune the parameters used in this experimentation.  

%-------------------------------------------------------------------------

\begin{table}[h]
  \vspace{-5pt}
\begin{center}
  \begin{tabular}{| c | c | c |}
    \hline
    Case & fc6 & fc7 \\ \hline \hline
   1 & dropout  & dropout \\ \hline
   2 & dropout  &  \\ \hline
   3 & dropout  & \dropin \\ \hline
  \end{tabular}
  \caption{The three regularization experiments shows layers with dropout or \dropin. The fully connected layers 6 and 7, are called \textit{fc6} and \textit{fc7}, respectively. }
  \label{tab:reg}
\end{center}
  \vspace{-15pt}
\end{table}


\begin{figure}[h]
%  \vspace{-15pt}
\begin{center}
%\fbox{\rule{0pt}{2in} \rule{0.9\linewidth}{0pt}}
   \includegraphics[width=.95\linewidth]{alexnet-regularization.png}
\end{center}
  \vspace{-10pt}
   \caption{Test of \dropin regularization with AlexNet. Validation data classification accuracy while training AlexNet with ImageNet data.  % See text for a discussion. 
(Best viewed in color) 
}
\label{fig:regularization}
  \vspace{-15pt}
\end{figure}


%-------------------------------------------------------------------------


\subsection{Using \dropin for regularization}
\label{sec:regularization}
The original AlexNet architecture uses dropout for regularization during training in both fully connected layers and it provides a substantial increase in the network's accuracy.
AlexNet (with 8 layers) provides a means to test \dropin regularization.
For this experiment, three cases were run as shown in  Table \ref{tab:reg}.
Case 1 is the original AlexNet.

%\begin{enumerate*}
% \vspace{-5pt}
%\item The original architecture (dropout in the fully connected layers 6 and 7, called fc6 and fc7, respectively),
%\item Dropout removed from fc7 but remaining in fc6, 
%\item \dropin in fc7 and dropout in fc6. 
%\end{enumerate*}



The results from this experiment are shown in Figure \ref{fig:regularization},
%where the blue curve is standard AlexNet, the green curve is without dropout in layer fc7, and the red curve is with \dropin in layer fc7.
where both \dropin and dropout probability ratios were $ 0.5 $ for all of these tests and all the other hyper-parameters were the same.
This figure shows that removing dropout from fc7 causes visible degrading of the accuracy between iterations 150,000 and 200,000 (green curve).
This kind of degradation does not happen with \dropinNS.
Instead, the accuracy curve is similar to the curve with dropout (red versus blue curve) but with a small degradation in overall performance.
We believe this degradation is because a \dropin network is more difficult to train than a dropout network.
However, the final accuracy for the network with \dropin in fc7 is higher than from an architecture without dropout (red versus green curve).
This experiment  demonstrates that \dropin provides some regularization since the degradation found in the case without dropout is absent.


%There are two implications from the accuracy from this for the first 100,000 iterations being far below that of AlexNet.
%First, using \dropin could be  only partially utilizing the fc7 layer since half of those activations are replaced with fc6 activations.
%Second, the change to the architecture introduced by \dropin in fc7 might make it harder to train the network and that the hyper-parameters need to be tuned.
%Future plans include tuning the network to determine if  the \dropin architecture can produce competitive accuracies to the original AlexNet.

%-------------------------------------------------------------------------

\section{How to determine a good architecture}

One of the challenges for deep learning practitioners is to determine good choices for the hyper-parameter values and the architecture for a given application and dataset.
\dropin and dropout provide an easier way to test choices for the architecture than running a set of experiments with many different architectures.

\dropin and dropout can allow one to test a range of architecture depths and widths, respectively.
Since adding layers does not necessarily increase accuracy, one can run with the gradual \dropin mode to see if there is little effect, such as in Figures \ref{fig:lenet_10} and  \ref{fig:cifarDropinLen}, or visible effect, such as in Figure \ref{fig:AlexLengths}.
Substantial improvement implies that there will be benefit from the additional depth.

Similarly, making a run where the dropout ratio varies from perhaps 0.9 to 0.1 (using a slightly modified dropout) provides guidance on the minimum number of neurons per layer.
When decreasing the probability that neurons are retained (as shown in Figure 9 of Srivastava \etal \cite{srivastava2014dropout}), the error typically has a range of the probability ratios where the error plateaus but at some threshold probability the error increases.
By multiplying the number of neurons in a layer by this threshold probability, one can approximately determine the minimum number of neurons one must retain where there is marginal harm to the accuracy.

%One can also start from fully trained weights and fine-tuning while letting the dropout ratio increase (thinner network) or letting the \dropin ratio increase (shallower network).
%If the effect on the accuracy is small and there is a need for computational savings, one can use the thinner and shallower network.
%If at a certain ratio for either dropout or \dropin there is an acceleration in the error, this ratio can be used to estimate the minimum depth and neurons per layer of the architecture for this dataset. 

%Furthermore, since \dropin and dropout allow for incremental changes to the architecture depth and width, one of our future research directions is to investigate automatic ways to learn an architecture during training.

%-------------------------------------------------------------------------

\section{Conclusion}

The major result of this paper is that deeper architectures that cannot converge using standard training methods, become trainable by slowly adding in the new layers during the training.  
In addition, there are indications that  \dropin layers help regularize the training of a network. 
We found in general that if the shallow network is trainable, then the deeper network, where  additional layers are added by a \dropin layer, is also trainable.  
%However, if the dataset is relatively small, a deeper network might not provide much improvement, as shown with the CIFAR-10 results.  
With a large dataset like ImageNet, adding additional layers increases accuracy.

We have not yet explored training with tailored \dropin lengths for different \dropin layers in a network.
In addition, comparing \dropin to initializing the weights from training a separate shallow network has not yet been tested; these are planned for future work and will be reported elsewhere.  
Also we plan to test \dropin within other architectures such as recurrent neural networks.
Future work also includes training networks with hundreds of layers using asynchronous \dropinNS, where layers are added starting at different iterations.
In addition, we wish to test training where the entire very deep network is initially very thin (few parameters to train) and units are added to all the layers during the training.
Furthermore, we plan to study if a methodology can be developed to learn from the data how to automatically optimize the architecture during training and thus learn to adapt to an application based on its data.

%-------------------------------------------------------------------------


{\small
\bibliographystyle{ieee}
\bibliography{dropin.bib}
}

\end{document}
