\documentclass{article}

% if you need to pass options to natbib, use, e.g.:
% \PassOptionsToPackage{numbers, compress}{natbib}
% before loading nips_2016
%
% to avoid loading the natbib package, add option nonatbib:
% \usepackage[nonatbib]{nips_2016}
%\PassOptionsToPackage{authoryear}{natbib}
%\PassOptionsToPackage{backend=bibtex}{natbib}
\usepackage[final]{nips_2016}

% to compile a camera-ready version, add the [final] option, e.g.:
% \usepackage[final]{nips_2016}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
%\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography

% basic
\usepackage{color,xcolor}
\usepackage{epsfig}
\usepackage{graphicx}

% figure and table
\usepackage{adjustbox}
\usepackage{array}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{float,wrapfig}
\usepackage{hhline}
\usepackage{multirow}
\usepackage{subcaption}

% font and character
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{bm}
\usepackage{nicefrac}
\usepackage{microtype}

% layout
\usepackage{changepage}
\usepackage{extramarks}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{setspace}
\usepackage{soul}
\usepackage{xspace}

% ref
\usepackage[pagebackref=true,breaklinks=true,colorlinks,citecolor=gray]{hyperref}
\usepackage{url}

% misc
\usepackage{algorithm, algorithmic}
\usepackage{enumerate}
\usepackage{todonotes}

% require xspace, array
%% layout
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\newcommand{\xpar}[1]{\noindent\textbf{#1}\ \ }
\newcommand{\vpar}[1]{\vspace{3mm}\noindent\textbf{#1}\ \ }

\newcommand{\rulesep}{\unskip\ \vrule\ }

%% notations
\newcommand{\sect}[1]{Section~\ref{#1}}
\newcommand{\ssect}[1]{\S~\ref{#1}}
\newcommand{\eqn}[1]{Equation~\ref{#1}}
\newcommand{\fig}[1]{Figure~\ref{#1}}
\newcommand{\tbl}[1]{Table~\ref{#1}}

\newcommand{\degree}{\ensuremath{^\circ}\xspace}
\newcommand{\norm}[1]{\lVert#1\rVert}
\newcommand{\fcseven}{$\mbox{fc}_7$}

\renewcommand*{\thefootnote}{\fnsymbol{footnote}}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\def\naive{na\"{\i}ve\xspace}
\def\Naive{Na\"{\i}ve\xspace}

\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}

\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{c.f}\onedot} \def\Cf{\emph{C.f}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot}
\def\etal{\emph{et al}\onedot}
\makeatother

%% comments
\definecolor{MyDarkBlue}{rgb}{0,0.08,1}
\definecolor{MyDarkGreen}{rgb}{0.02,0.6,0.02}
\definecolor{MyDarkRed}{rgb}{0.8,0.02,0.02}
\definecolor{MyDarkOrange}{rgb}{0.40,0.2,0.02}
\definecolor{MyPurple}{RGB}{111,0,255}
\definecolor{MyRed}{rgb}{1.0,0.0,0.0}
\definecolor{MyGold}{rgb}{0.75,0.6,0.12}
\definecolor{MyDarkGray}{rgb}{0.66, 0.66, 0.66}

\newcommand{\modelfull}{3D Generative Adversarial Network\xspace}
\newcommand{\model}{3D-GAN\xspace}
\newcommand{\mdls}{3D-GANs\xspace}
\newcommand{\vaemodel}{3D-VAE-GAN\xspace}
\newcommand{\vaemodels}{3D-VAE-GANs\xspace}

\newcommand{\myparagraph}[1]{\vspace{-10pt}\paragraph{#1}}

\newcommand{\presection}{\vspace{-8pt}}
\newcommand{\postsection}{\vspace{-8pt}}
\newcommand{\presubsection}{\vspace{-8pt}}
\newcommand{\postsubsection}{\vspace{-6pt}}

\title{Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling}

\author{Jiajun Wu* \qquad\qquad\qquad Chengkai Zhang* \qquad\qquad\qquad\; Tianfan Xue \\
MIT CSAIL \qquad\qquad\qquad\quad\; MIT CSAIL \qquad\qquad\qquad\quad\;\;\; MIT CSAIL \quad\\
\AND
William T. Freeman \qquad\qquad\qquad Joshua B. Tenenbaum\\
MIT CSAIL, Google Research \quad\qquad\qquad\quad MIT CSAIL \qquad\qquad\qquad\\
}

\begin{document}

\maketitle
\footnotetext{$*$ indicates equal contributions. Emails: \{jiajunwu, ckzhang, tfxue, billf, jbt\}@mit.edu}

\vspace{-5pt}
\presection
\begin{abstract}
\postsection

We study the problem of 3D object generation. We propose a novel framework, namely \modelfull (\model), which generates 3D objects from a probabilistic space by leveraging recent advances in volumetric convolutional networks and generative adversarial nets. The benefits of our model are three-fold: first, the use of an adversarial criterion, instead of traditional heuristic criteria, enables the generator to capture object structure implicitly and to synthesize high-quality 3D objects; second, the generator establishes a mapping from a low-dimensional probabilistic space to the space of 3D objects, so that we can sample objects without a reference image or CAD models, and explore the 3D object manifold; third, the adversarial discriminator provides a powerful 3D shape descriptor which, learned without supervision, has wide applications in 3D object recognition. Experiments demonstrate that our method generates high-quality 3D objects, and our unsupervisedly learned features achieve impressive performance on 3D object recognition, comparable with those of supervised learning methods.
\vspace{-5pt}

\end{abstract}

\presection 
\section{Introduction}
\label{sec:intro}
\postsection

What makes a 3D generative model of object shapes appealing? We believe a good generative model should be able to synthesize 3D objects that are both highly varied and realistic. Specifically, for 3D objects to have variations, a generative model should be able to go beyond memorizing and recombining parts or pieces from a pre-defined repository to produce novel shapes; and for objects to be realistic, there need to be fine details in the generated examples.

In the past decades, researchers have made impressive progress on 3D object modeling and synthesis~\citep{van2011survey,tangelder2008survey,carlson1982algorithm}, mostly based on meshes or skeletons.  Many of these traditional methods synthesize new objects by borrowing parts from objects in existing CAD model libraries. Therefore, the synthesized objects look realistic, but not conceptually novel. 

Recently, with the advances in deep representation learning and the introduction of large 3D CAD datasets like ShapeNet~\citep{chang2015shapenet,wu20153d}, there have been some inspiring attempts in learning deep object representations based on voxelized objects~\citep{girdhar2016learning,su2015multi,qi2016volumetric}. 
Different from part-based methods, many of these generative approaches do not explicitly model the concept of parts or retrieve them from an object repository; instead, they synthesize new objects based on learned object representations. This is a challenging problem because, compared to the space of 2D images, it is more difficult to model the space of 3D shapes due to its higher dimensionality.
Their current results are encouraging, but often there still exist artifacts (\eg, fragments or holes) in the generated objects. 

In this paper, we demonstrate that modeling volumetric objects in a general-adversarial manner could be a promising solution to generate objects that are both novel and realistic. Our approach combines the merits of both general-adversarial  modeling~\citep{goodfellow2014generative,radford2016unsupervised} and volumetric convolutional networks~\citep{maturana2015voxnet,wu20153d}.
Different from traditional heuristic criteria, generative-adversarial modeling introduces an adversarial discriminator to classify whether an object is synthesized or real. 
This could be a particularly favorable framework for 3D object modeling: as 3D objects are highly structured, a generative-adversarial criterion, but not a voxel-wise independent heuristic one, has the potential to capture the structural difference of two 3D objects.
The use of a generative-adversarial loss may also avoid possible criterion-dependent overfitting  (\eg, generating mean-shape-like blurred objects when minimizing a mean squared error). 

Modeling 3D objects in a generative-adversarial way offers additional distinctive advantages. First, it becomes possible to sample novel 3D objects from a probabilistic latent space such as a Gaussian or uniform distribution. Second, the discriminator in the generative-adversarial approach carries informative features for 3D object recognition, as demonstrated in experiments (\sect{sec:results}). From a different perspective, instead of learning a single feature representation for both generating and recognizing objects~\citep{girdhar2016learning,sharma2016vconv}, our framework learns disentangled generative and discriminative representations for 3D objects without supervision, and applies them on generation and recognition tasks, respectively.

We show that our generative representation can be used to synthesize high-quality realistic objects, and our discriminative representation can be used for 3D object recognition, achieving comparable performance with recent supervised methods~\citep{maturana2015voxnet,shi2015deeppano}, and outperforming other unsupervised methods by a large margin. The learned generative and discriminative representations also have wide applications. For example, we show that our network can be combined with a variational autoencoder~\citep{kingma2014auto,larsen2015autoencoding} to directly reconstruct a 3D object from a 2D input image. Further, we explore the space of object representations and demonstrate that both our generative and discriminative representations carry rich semantic information about 3D objects. 

\presection
\section{Related Work}
\label{sec:related_work}
\postsection

\paragraph{Modeling and synthesizing 3D shapes}
3D object understanding and generation is an important problem in the graphics and vision community, and the relevant literature is very rich~\citep{carlson1982algorithm,tangelder2008survey,van2011survey,blanz1999morphable,kalogerakis2012probabilistic,chaudhuri2011probabilistic,xue2012example,kar2015category,bansal2016marr,wu2016single}. Since decades ago, AI and vision researchers have made inspiring attempts to design or learn 3D object representations, mostly based on meshes and skeletons. Many of these shape synthesis algorithms are nonparametric and they synthesize new objects by retrieving and combining shapes and parts from a database. Recently, \cite{huang2015analysis} explored generating 3D shapes with pre-trained templates and producing both object structure and surface geometry. Our framework synthesizes objects without explicitly borrow parts from a repository, and requires no supervision during training. %\jw{to be updated}

\myparagraph{Deep learning for 3D data} 
The vision community have witnessed rapid development of deep networks for various tasks. In the field of 3D object recognition, \cite{li2015joint,su15,girdhar2016learning} proposed to learn a joint embedding of 3D shapes and synthesized images, \cite{su2015multi,qi2016volumetric} focused on learning discriminative representations for 3D object recognition, \cite{wu2016single,xiang2015data,choy20163d} discussed 3D object reconstruction from in-the-wild images, possibly with a recurrent network, and \cite{girdhar2016learning,sharma2016vconv} explored autoencoder-based networks for learning voxel-based object representations. \cite{wu20153d,rezende2016unsupervised,yan2016projective} attempted to generate 3D objects with deep networks, some using 2D images during training with a 3D to 2D projection layer. Many of these networks can be used for 3D shape classification~\citep{su2015multi,sharma2016vconv,maturana2015voxnet}, 3D shape retrieval~\citep{shi2015deeppano,su2015multi}, and single image 3D reconstruction~\citep{kar2015category,bansal2016marr,girdhar2016learning}, mostly with full supervision. In comparison, our framework requires no supervision for training, is able to generate objects from a probabilistic space, and comes with a rich discriminative 3D shape representation.

\myparagraph{Learning with an adversarial net} Generative Adversarial Nets (GAN)~\citep{goodfellow2014generative} proposed to incorporate an adversarial discriminator into the procedure of generative modeling. More recently, LAPGAN~\citep{denton2015deep} and DC-GAN~\citep{radford2016unsupervised} adopted GAN with convolutional networks for image synthesis, and achieved impressive performance. Researchers have also explored the use of GAN for other vision problems. To name a few, \cite{wang2016generative} discussed how to model image style and structure with sequential GANs, \cite{li2016precomputed} and \cite{zhu2016generative} used GAN for texture synthesis and image editing, respectively, and \cite{im2016generating} developed a recurrent adversarial network for image generation. While previous approaches focus on modeling 2D images, we discuss the use of an adversarial component in modeling 3D objects.


\presection
\section{Models}
\label{sec:model}
\postsection

\begin{figure}[t]
\centering
\vspace{-5pt}
\includegraphics[width=0.9\linewidth]{model.pdf}
\vspace{-8pt}
\caption{The generator in \model. The discriminator mostly mirrors the generator. }
\vspace{-18pt}
\label{fig:model}
\end{figure}

In this section we introduce our model for 3D object generation. We first discuss how we build our framework, \modelfull (\model), by leveraging previous advances on volumetric convolutional networks and generative adversarial nets. We then show how to train a variational autoencoder~\citep{kingma2014auto} simultaneously so that our framework can capture a mapping from a 2D image to a 3D object. 

\presubsection
\subsection{\modelfull (\model)}
\label{sec:gan}
\postsubsection

As proposed in \cite{goodfellow2014generative}, the Generative Adversarial Network (GAN) consists of a generator and a discriminator, where the discriminator tries to classify real objects and objects synthesized by the generator, and the generator attempts to confuse the discriminator. In our \modelfull (\model), the generator $G$ maps a $200$-dimensional latent vector $z$, randomly sampled from a probabilistic latent space, to a $64\times 64\times 64$ cube, representing an object $G(z)$ in 3D voxel space. The discriminator $D$ outputs a confidence value $D(x)$ of whether a 3D object input $x$ is real or synthetic. 

Following \cite{goodfellow2014generative}, we use binary cross entropy as the classification loss, and present our overall adversarial loss function as 

\vspace{-10pt}
\begin{equation}
\label{eq:ganloss}
L_{\text{\model}}=\log D(x) + \log (1-D(G(z))),
\end{equation}
\vspace{-9pt}

where $x$ is a real object in a $64\times 64\times 64$ space, and $z$ is a randomly sampled noise vector from a distribution $p(z)$. In this work, each dimension of $z$ is an i.i.d. uniform distribution over $[0,1]$. 

\myparagraph{Network structure} Inspired by \cite{radford2016unsupervised}, we design an all-convolutional neural network to generate 3D objects. As shown in Figure \ref{fig:model}, the generator consists of five volumetric fully convolutional layers of kernel sizes $4\times4\times4$ and strides $2$, with batch normalization and ReLU layers added in between and a Sigmoid layer at the end. The discriminator basically mirrors the generator, except that it uses Leaky ReLU~\citep{maas2013rectifier} instead of ReLU layers. 
There are no pooling or linear layers in our network. More details can be found in the supplementary material.

\myparagraph{Training details} A straightforward training procedure is to update both the generator and the discriminator in every batch. 
However, the discriminator usually learns much faster than the generator, possibly because generating objects in a 3D voxel space is more difficult than differentiating between real and synthetic objects~\citep{goodfellow2014generative,radford2016unsupervised}.  It then becomes hard for the generator to extract signals for improvement from a discriminator that is way ahead, as all examples it generated would be correctly identified as synthetic with high confidence.
Therefore, to keep the training of both networks in pace, we employ an adaptive training strategy: for each batch, the discriminator only gets updated if its accuracy in the last batch is not higher than $80\%$. We observe this helps to stabilize the training and to produce better results. We set the learning rate of $G$ to $0.0025$, $D$ to $10^{-5}$, and use a batch size of $100$. We use ADAM~\citep{kingma2014adam} for optimization, with $\beta=0.5$.

\presubsection
\subsection{\vaemodel}
\label{sec:vaegan}
\postsubsection


We have discussed how to generate 3D objects by sampling a latent vector $z$ and mapping it to the object space. In practice, it would also be helpful to infer these latent vectors from observations. For example, if there exists a mapping from a 2D image to the latent representation, we can then recover the 3D object corresponding to that 2D image.

Following this idea, we introduce \vaemodel as an extension to \model.
We add an additional image encoder $E$, which takes a 2D image $x$ as input and outputs the latent representation vector $z$. This is inspired by VAE-GAN proposed by \citep{larsen2015autoencoding}, which combines VAE and GAN by sharing the decoder of VAE with the generator of GAN. 

The \vaemodel therefore consists of three components: an image encoder $E$, a decoder (the generator $G$ in \model), and a discriminator $D$. The image encoder consists of five spatial convolution layers with kernel size $\{11,5,5,5,8\}$ and strides $\{4,2,2,2,1\}$, respectively. There are batch normalization and ReLU layers in between, and a sampler at the end to sample a $200$ dimensional vector used by the \model. The structures of the generator and the discriminator are the same as those in \sect{sec:gan}.

Similar to VAE-GAN~\citep{larsen2015autoencoding}, our loss function consists of three parts: an object reconstruction loss $L_{\text{recon}}$, a cross entropy loss $L_{\text{\model}}$ for \model, and a KL divergence loss $L_{\text{KL}}$ to restrict the distribution of the output of the encoder. Formally, these loss functions write as 
\begin{equation}
\label{eq:vaeloss}
L=L_{\text{\model}}+\alpha_1 L_{\text{KL}}+\alpha_2 L_{\text{recon}},
\end{equation}
where $\alpha_1$ and $\alpha_2$ are weights of the KL divergence loss and the reconstruction loss. We have
\begin{align}
L_{\text{\model}}& = \log D(x) + \log (1-D(G(z))), \\
L_{\text{KL}} &= D_{\text{KL}}(q(z|y)\mid\mid p(z)),\\
L_{\text{recon}}&=||G(E(y)) - x||_2,
\end{align}
where $x$ is a 3D shape from the training set, $y$ is its corresponding 2D image, and $q(z|y)$ is the variational distribution of the latent representation $z$. The KL-divergence pushes this variational distribution towards to the prior distribution $p(z)$, so that the generator can sample the latent representation $z$ from the same distribution $p(z)$. In this work, we choose $p(z)$ a multivariate Gaussian distribution with zero-mean and unit variance. For more details, please refer to \cite{larsen2015autoencoding}.

Training \vaemodel requires both 2D images and their corresponding 3D models. We render 3D shapes in front of background images ($16,913$ indoor images from the SUN database~\citep{SUN}) in $72$ views (from $24$ angles and $3$ elevations). We set $\alpha_1=5$, $\alpha_2=10^{-4}$, and use a similar training strategy as in \sect{sec:gan}. See our supplementary material for more details.


\presection
\section{Evaluation}
\label{sec:results}
\postsection

\begin{figure}[t]
\centering{
\renewcommand{\arraystretch}{0}
\begin{tabular}{L{0.06\linewidth}C{0.65\linewidth}|C{0.20\linewidth}}
& Our results ($64\times64\times64$) & NN\\
Gun&
\includegraphics[width=1\linewidth]{gun64.png}&
\includegraphics[width=.48\linewidth]{nn_18.png}
\includegraphics[width=.48\linewidth]{nn_8.png}\\
Chair&
\includegraphics[width=1\linewidth]{chair64.png}&
\includegraphics[width=.48\linewidth]{nn_2.png}
\includegraphics[width=.48\linewidth]{nn_6.png}\\
Car&
\includegraphics[width=1\linewidth]{car64.png}&
\includegraphics[width=.48\linewidth]{nn_20.png}
\includegraphics[width=.48\linewidth]{nn_10.png}\\
Sofa&
\includegraphics[width=1\linewidth]{sofa64.png}&
\includegraphics[width=.48\linewidth]{nn_16.png}
\includegraphics[width=.48\linewidth]{nn_4.png}\\
Table&
\includegraphics[width=1\linewidth]{table64.png}&
\includegraphics[width=.48\linewidth]{nn_14.png}
\includegraphics[width=.48\linewidth]{nn_12.png}
\end{tabular}
}

\hrule
\vspace{5pt}

Objects generated by \cite{wu20153d} ($30\times30\times30$)
\begin{tabular}{L{0.06\linewidth}C{0.38\linewidth}R{0.06\linewidth}C{0.38\linewidth}}
Table&
\includegraphics[width=1\linewidth]{shapenet_table_1.png}&
Car&
\includegraphics[width=1\linewidth]{shapenet_car_2.png}\\
\end{tabular}

\vspace{3pt}
Objects generated by a volumetric autoencoder ($64\times 64\times 64$)
\vspace{3pt}

\begin{tabular}{L{0.06\linewidth}C{0.064\linewidth}C{0.064\linewidth}C{0.064\linewidth}L{0.06\linewidth}C{0.064\linewidth}C{0.064\linewidth}C{0.064\linewidth}L{0.05\linewidth}C{0.064\linewidth}C{0.064\linewidth}}
Chair &
\includegraphics[width=1\linewidth]{ae_chair_58.png}&
\includegraphics[width=1\linewidth]{ae_chair_64.png}&
\includegraphics[width=1\linewidth]{ae_chair_9.png}&
Table &
\includegraphics[width=1\linewidth]{ae_desk_15.png}&
\includegraphics[width=1\linewidth]{ae_desk_23.png}&
\includegraphics[width=1\linewidth]{ae_desk_45.png}&
Sofa &
\includegraphics[width=1\linewidth]{ae_sofa_4.png}&
\includegraphics[width=1\linewidth]{ae_sofa_9.png}
\end{tabular}
\vspace{-8pt}

\caption{Objects generated by \model from vectors, without a reference image/object. We show, for the last two objects in each row, the nearest neighbor retrieved from the training set. We see that the generated objects are similar, but not identical, to examples in the training set. For comparison, we show objects generated by the previous state-of-the-art~\citep{wu20153d} (results supplied by the authors). We also show objects generated by autoencoders trained on a single object category, with latent vectors sampled from empirical distribution. See text for details. }

\label{fig:results}
\vspace{-12pt}
\end{figure}

\begin{figure}[t]
\centering
\begin{tabular}{C{0.22\linewidth}C{0.22\linewidth}C{0.22\linewidth}C{0.22\linewidth}}
\includegraphics[width=0.48\linewidth]{res_2.png}
\includegraphics[width=0.48\linewidth]{res_1.png}&
\includegraphics[width=0.48\linewidth]{res_4.png}
\includegraphics[width=0.48\linewidth]{res_3.png}&
\includegraphics[width=0.48\linewidth]{res_6.png}
\includegraphics[width=0.48\linewidth]{res_5.png}&
\includegraphics[width=0.48\linewidth]{res_8.png}
\includegraphics[width=0.48\linewidth]{res_7.png}\\
High-res \quad Low-res & High-res \quad Low-res & High-res \quad Low-res & High-res \quad Low-res 
\end{tabular}
\vspace{-5pt}
\caption{We present each object at high resolution ($64\times64\times64$) on the left and at low resolution (down-sampled to $16\times16\times16$) on the right. While humans can perceive object structure at a relatively low resolution, fine details and variations only appear in high-res objects.}
\vspace{-20pt}
\label{fig:nn}
\end{figure}

In this section, we evaluate our framework from various aspects. We first show qualitative results of generated 3D objects. We then evaluate the unsupervisedly learned representation from the discriminator by using them as features for 3D object classification. We show both qualitative and quantitative results on the popular benchmark ModelNet~\citep{wu20153d}. Further, we evaluate our \vaemodel on 3D object reconstruction from a single image, and show both qualitative and quantitative results on the IKEA dataset~\citep{ikea}. 

\presubsection
\subsection{3D Object Generation}
\postsubsection

\fig{fig:results} shows 3D objects generated by our \model. 
For this experiment, we train one \model for each object category. For generation, we sample $200$-dimensional vectors following an i.i.d. uniform distribution over $[0,1]$, and render the largest connected component of each generated object. 
We compare \model with \cite{wu20153d}, the state-of-the-art in 3D object synthesis from a probabilistic space, and with a volumetric autoencoder, whose variants have been employed by multiple recent methods~\citep{girdhar2016learning,sharma2016vconv}. Because an autoencoder does not restrict the distribution of its latent representation, we compute the empirical distribution $p_0(z)$ of the latent vector $z$ of all training examples, fit a Gaussian distribution $g_0$ to $p_0$, and sample from $g_0$. Our algorithm produces 3D objects with much higher quality and more fine-grained details.

Compared with previous works, our \model can synthesize high-resolution 3D objects with detailed geometries. \fig{fig:nn} shows both high-res voxels and down-sampled low-res voxels for comparison. Note that it is relatively easy to synthesize a low-res object, but is much harder to obtain a high-res one due to the rapid growth of 3D space. However, object details are only revealed in high resolution. 

A natural concern to our generative model is whether it is simply memorizing objects from training data. 
To demonstrate that the network can generalize beyond the training set, we compare synthesized objects with their nearest neighbor in the training set. Since the retrieval objects based on $\ell^2$~distance in the voxel space are visually very different from the queries, we use the output of the last convolutional layer in our discriminator (with a 2x pooling) as features for retrieval instead.
\fig{fig:results} shows that generated objects are similar, but not identical, to the nearest examples in the training set. 

\begin{table}[t]
\begin{center}
\small
\begin{tabular}{lllcc}
\toprule
\multirow{2}{*}{\bf Supervision} & \multirow{2}{*}{\bf Pretraining} & \multirow{2}{*}{\bf Method} & \multicolumn{2}{c}{\bf Classification (Accuracy)}  \\
\cmidrule{4-5}
& & & ModelNet40 & ModelNet10 \\
\midrule
\multirow{6}{*}{Category labels} & \multirow{2}{*}{ImageNet} &MVCNN~\citep{su2015multi} & 90.1\% & - \\
& &MVCNN-MultiRes~\citep{qi2016volumetric} & {\bf 91.4}\% & - \\
\cmidrule{2-5}
& \multirow{4}{*}{None} &3D ShapeNets~\citep{wu20153d} & 77.3\% & 83.5\%\\
& &DeepPano~\citep{shi2015deeppano} & 77.6\% & 85.5\% \\
& &VoxNet~\citep{maturana2015voxnet} & 83.0\% & 92.0\% \\
& &ORION~\citep{sedaghat2016orientation} & - & {\bf 93.8}\% \\
\midrule
\multirow{5}{*}{Unsupervised} & \multirow{5}{*}{-} & SPH~\citep{kazhdan2003rotation} & 68.2\% & 79.8\%\\
& &LFD~\citep{chen2003visual} & 75.5\% & 79.9\% \\
& &T-L Network~\citep{girdhar2016learning} & 74.4\% & -\\
& &VConv-DAE~\citep{sharma2016vconv} & 75.5\% & 80.5\% \\
& &\model (ours) & {\bf 83.3}\% & {\bf 91.0}\% \\    
\bottomrule
\end{tabular}
\end{center}
\caption{Classification results on the ModelNet dataset. Our \model outperforms other unsupervised learning methods by a large margin, and is comparable to some recent supervised learning frameworks.}
\vspace{-15pt}
\label{tbl:modelnet}
\end{table}

\begin{figure}[t]
\begin{minipage}[m]{0.32\linewidth}
\includegraphics[width=\linewidth]{classification.pdf}
\vspace{-15pt}
\caption{ModelNet40 classification with limited training data}
\label{fig:datasize}
\end{minipage}
\hfill
\begin{minipage}[m]{0.66\linewidth}
\centering
\includegraphics[trim={80px 0 80px 0},clip,width=0.13\linewidth]{0021_2.png} 
\includegraphics[trim={80px 0 80px 0},clip,width=0.13\linewidth]{0021_2_2.png} 
\includegraphics[trim={80px 0 80px 0},clip,width=0.13\linewidth]{0022_2.png} 
\includegraphics[trim={80px 0 80px 0},clip,width=0.13\linewidth]{0016_2.png} 
\includegraphics[trim={80px 0 80px 0},clip,width=0.13\linewidth]{0031_4.png} 
\includegraphics[trim={80px 0 80px 0},clip,width=0.13\linewidth]{0041_2.png} 
\includegraphics[trim={80px 0 80px 0},clip,width=0.13\linewidth]{0051_2.png} 
\vspace{-2pt}
\caption{The effects of individual dimensions of the object vector}
\label{fig:visvect}
\vspace{7pt}
\includegraphics[width=\linewidth]{inter_chair00.png}
\includegraphics[width=\linewidth]{inter_mix700.png}
\vspace{-20pt}
\caption{Intra/inter-class interpolation between object vectors}
\label{fig:interp}
\end{minipage}
\vspace{-15pt}
\end{figure}

\begin{table}[t]
\small
\begin{center}
\begin{tabular}{lccccccc}
\toprule
Method & Bed & Bookcase & Chair & Desk & Sofa & Table & Mean \\
\midrule
AlexNet-fc8~\citep{girdhar2016learning} & 29.5 & 17.3 & 20.4 & 19.7 & 38.8 & 16.0 & 23.6 \\
AlexNet-conv4~\citep{girdhar2016learning} & 38.2 & 26.6 & 31.4 & 26.6 & 69.3 & 19.1 & 35.2 \\
T-L Network~\citep{girdhar2016learning} & 56.3 & 30.2 & 32.9 & 25.8 & 71.7 & 23.3 & 40.0 \\
\midrule
\vaemodel (jointly trained) & 49.1 & 31.9 & 42.6 & 34.8 & {\bf 79.8} & 33.1 & 45.2\\
\vaemodel (separately trained) & {\bf 63.2} & {\bf 46.3} & {\bf 47.2} &{\bf 40.7}  &  78.8 & {\bf 42.3} & {\bf 53.1}\\
\bottomrule
\end{tabular}
\end{center}
\caption{Average precision for voxel prediction on the IKEA dataset.$^\dagger$}
\label{tbl:ikea}
\vspace{-15pt}
\end{table}

\begin{figure}[t]
\centering
\begin{tabular}{L{\linewidth}}
\centering
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0104.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_104c.png}}
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0058.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_58u.png}}
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0172.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_172c.png}}
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0032.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_32c.png}}
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0175.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_175u.png}}\\
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0134.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_134c.png}}
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0011.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_11c.png}}
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0151.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_151c.png}}
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0180.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_180c.png}}
\raisebox{-0.5\height}{\includegraphics[width=0.09\linewidth]{recon_0210.png}}
\raisebox{-0.5\height}{\includegraphics[trim={50px 0 50px 0},clip,width=0.09\linewidth]{recon_210c.png}}
\end{tabular}
\vspace{-8pt}
\caption{Qualitative results of single image 3D reconstruction on the IKEA dataset}
\label{fig:ikea}
\vspace{-18pt}
\end{figure}


\begin{figure}[t]
\centering
\begin{tabular}{cc}
    \includegraphics[width=0.45\linewidth]{arith_chair.jpg} &
    \includegraphics[width=0.45\linewidth]{arith_desk.jpg} \\
\end{tabular}
\vspace{-8pt}
\caption{Shape arithmetic for chairs and tables. The left images show the obtained ``arm'' vector can be added to other chairs, and the right ones show the ``layer'' vector can be added to other tables. }
\label{fig:arith}
\vspace{-10pt}
\end{figure}


\begin{figure}[t!]
\small
\centering
\begin{tabular}{C{0.47\linewidth}C{0.47\linewidth}}
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0001_0021_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0001_0022_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0001_0023_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0001_0024_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0001_0025_2_2.png} &
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0002_0339_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0002_0340_2_2.png}
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0002_0341_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0002_0342_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0002_0343_2_2.png} \\
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0005_0373_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0005_0374_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0005_0376_2_2.png}
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0005_0379_2_2.png}
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0005_0380_2_2.png} &
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0006_0071_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0006_0072_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0006_0073_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0006_0074_2_2.png} 
\includegraphics[trim={200px 0 200px 0},clip,width=0.185\linewidth]{0006_0075_2_2.png} 
\end{tabular}
\vspace{-5pt}
\caption{Objects and parts that activate specific neurons in the discriminator. For each neuron, we show five objects that activate it most strongly, with colors representing gradients of activations with respect to input voxels.}
\label{fig:visunit}
\vspace{-15pt}
\end{figure}


\presubsection
\subsection{3D Object Classification}
\postsubsection

We then evaluate the representations learned by our discriminator. A typical way of evaluating representations learned without supervision is to use them as features for classification. 
To obtain features for an input 3D object, we concatenate the responses of the second, third, and fourth convolution layers in the discriminator, and apply max pooling of kernel sizes $\{8, 4, 2\}$, respectively. We use a linear SVM for classification.

\myparagraph{Data} We train a single \model on the seven major object categories (chairs, sofas, tables, boats, airplanes, rifles, and cars) of ShapeNet~\citep{chang2015shapenet}. We use ModelNet~\citep{wu20153d} for testing, following \cite{sharma2016vconv,maturana2015voxnet,qi2016volumetric}.\footnote{For ModelNet, there are two train/test splits typically used. \cite{qi2016volumetric,shi2015deeppano,maturana2015voxnet} used the train/test split included in the dataset, which we also follow; \cite{wu20153d,su2015multi,sharma2016vconv} used $80$ training points and $20$ test points in each category for experiments, possibly with viewpoint augmentation.} Specifically, we evaluate our model on both ModelNet10 and ModelNet40, two subsets of ModelNet that are often used as benchmarks for 3D object classification. Note that the training and test categories are not identical, which also shows the out-of-category generalization power of our \model.

\myparagraph{Results} We compare with the state-of-the-art methods~\citep{wu20153d,girdhar2016learning,sharma2016vconv,sedaghat2016orientation} and show per-class accuracy in \tbl{tbl:modelnet}. Our representation outperforms other features learned without supervision by a large margin ($83.3\%$ vs. $75.5\%$ on ModelNet40, and $91.0\%$ vs $80.5\%$ on ModelNet10)~\citep{girdhar2016learning,sharma2016vconv}. Further, our classification accuracy is also higher than some recent supervised methods~\citep{shi2015deeppano}, and is close to the state-of-the-art voxel-based supervised learning approaches~\citep{maturana2015voxnet,sedaghat2016orientation}. Multi-view CNNs~\citep{su2015multi,qi2016volumetric} outperform us, though their methods are designed for classification, and require rendered multi-view images and an ImageNet-pretrained model.

\model also works well with limited training data. As shown in \fig{fig:datasize}, with roughly 25 training samples per class, \model achieves comparable performance on ModelNet40 with other unsupervised learning methods trained with at least 80 samples per class.

\presubsection
\subsection{Single Image 3D Reconstruction}
\postsubsection

As an application, our show that the \vaemodel can perform well on single image 3D reconstruction. Following previous work~\citep{girdhar2016learning}, we test it on the IKEA dataset~\citep{ikea}, and show both qualitative and quantitative results.

\myparagraph{Data} 
The IKEA dataset consists of images with IKEA objects. We crop the images so that the objects are centered in the images. Our test set consists of $1,039$ objects cropped from $759$ images (supplied by the author). The IKEA dataset is challenging because all images are captured in the wild, often with heavy occlusions. We test on all six categories of objects: bed, bookcase, chair, desk, sofa, and table.

\myparagraph{Results} We show our results in \fig{fig:ikea} and \tbl{tbl:ikea}, with performance of a single \vaemodel jointly trained on all six categories, as well as the results of six \vaemodels separately trained on each class. Following \cite{girdhar2016learning}, we evaluate results at resolution $20\times20\times20$, use the average precision as our evaluation metric, and attempt to align each prediction with the ground-truth over permutations, flips, and translational alignments (up to 10\%), as IKEA ground truth objects are not in a canonical viewpoint. 
In all categories, our model consistently outperforms previous state-of-the-art in voxel-level prediction and other baseline methods.\footnote{For methods from \cite{girdhar2016learning}, the mean values in the last column are higher than the originals in their paper, because we compute per-class accuracy instead of per-instance accuracy.}

\presection
\section{Analyzing Learned Representations}
\label{sec:analysis}
\postsection

In this section, we look deep into the representations learned by both the generator and the discriminator of \model. We start with the $200$-dimensional object vector, from which the generator produces various objects. We then visualize neurons in the discriminator, and demonstrate that these units capture informative semantic knowledge of the objects, which justifies its good performance on object classification presented in \sect{sec:results}.

\presubsection
\subsection{The Generative Representation}
\label{sec:vector}
\postsubsection

We explore three methods for understanding the latent space of vectors for object generation. We first visualize what an individual dimension of the vector represents; we then explore the possibility of interpolating between two object vectors and observe how the generated objects change; last, we present how we can apply shape arithmetic in the latent space.

\myparagraph{Visualizing the object vector} 
To visualize the semantic meaning of each dimension, we gradually increase its value, and observe how it affects the generated 3D object. In \fig{fig:visvect}, each column corresponds to one dimension of the object vector, where the red region marks the voxels affected by changing values of that dimension. We observe that some dimensions in the object vector carries semantic knowledge of the object, \eg, the thickness or width of surfaces. 

\myparagraph{Interpolation} We show results of interpolating between two object vectors in \fig{fig:interp}. Earlier works demonstrated interpolation between two 2D images of the same category~\citep{dosovitskiy2015learning,radford2016unsupervised}. Here we show interpolations both within and across object categories. We observe that for both cases walking over the latent space gives smooth transitions between objects.

\myparagraph{Arithmetic} Another way of exploring the learned representations is to show arithmetic in the latent space. Previously, \cite{dosovitskiy2015learning,radford2016unsupervised} presented that their generative nets are able to encode semantic knowledge of chair or face images in its latent space; \cite{girdhar2016learning} also showed that the learned representation for 3D objects behave similarly. We show our shape arithmetic in \fig{fig:arith}. Different from \cite{girdhar2016learning}, all of our objects are randomly sampled, requiring no existing 3D CAD models as input.

\presubsection
\subsection{The Discriminative Representation}
\postsubsection

We now visualize the neurons in the discriminator. Specifically, we would like to show what input objects, 
and which part of them produce the highest intensity values for each neuron. To do that, for each neuron in the second to last convolutional layer of the discriminator, we iterate through all training objects and exhibit the ones activating the unit most strongly. We further use guided back-propagation~\citep{springenberg2014striving} to visualize the parts that produce the activation. 

\fig{fig:visunit} shows the results. There are two main observations: first, for a single neuron, the objects producing strongest activations have very similar shapes, showing the neuron is selective in terms of the overall object shape; second, the parts that activate the neuron, shown in red, are consistent across these objects, indicating the neuron is also learning semantic knowledge about object parts.


\presection
\section{Conclusion}
\postsection

In this paper, we proposed \model for 3D object generation, as well as \vaemodel for learning an image to 3D model mapping. We demonstrated that our models are able to generate novel objects and to reconstruct 3D objects from images. We showed that the discriminator in GAN, learned without supervision, can be used as an informative feature representation for 3D objects, achieving impressive performance on shape classification. We also explored the latent space of object vectors, and presented results on object interpolation, shape arithmetic, and neuron visualization.

\presection
\paragraph{Acknowledgement} This work is supported by NSF grants \#1212849 and \#1447476, ONR MURI N00014-16-1-2007, the Center for Brain, Minds and Machines (NSF STC award CCF-1231216), Toyota Research Institute, Adobe, Shell, IARPA MICrONS, and a hardware donation from Nvidia. 
\postsection{\small
\setlength{\bibsep}{0pt}
\bibliographystyle{plainnat}
\bibliography{shape}
}

\newpage
\appendix
\renewcommand{\thesection}{A.\arabic{section}}
\renewcommand{\thefigure}{A\arabic{figure}}
\setcounter{section}{0}
\setcounter{figure}{0}

\section{Network Structure}
Here we give the network structures of the generator, the discriminator, and the image encoder. 

{\bf Generator} The generator consists of five fully convolution layers with numbers of channels $\{512,256,128,64,1\}$, kernel sizes $\{4,4,4,4,4\}$, and strides $\{1,2,2,2,2\}$. We add ReLU and batch normalization layers between convolutional layers, and a Sigmoid layer at the end. 
The input is a $200$-dimensional vector, and the output is a $64\times64\times64$ matrix with values in $[0,1]$.     

{\bf Discriminator} As a mirrored version of the generator, the discriminator takes as input a $64\times64\times64$ matrix, and outputs a real number in $[0,1]$. The discriminator consists of $5$ volumetric convolution layers, with numbers of channels $\{64,128,256,512,1\}$, kernel sizes $\{4,4,4,4,4\}$, and strides $\{2,2,2,2,1\}$. There are leaky ReLU layers of parameter $0.2$ and batch normalization layers in between, and a Sigmoid layer at the end. 

{\bf Image encoder} The image encoder in our \vaemodel takes a $3\times256\times256$ image as input, and outputs a $200$-dimensional vector. It consists of five spatial convolution layers with numbers of channels $\{64,128,256,512,400\}$, kernel sizes $\{11,5,5,5,8\}$, and strides $\{4,2,2,2,1\}$, respectively. There are ReLU and batch normalization layers in between. The output of the last convolution layer is a $400$-dimensional vector representing a Gaussian distribution in the $200$-dimensional space, where $200$ dimensions are for the mean and the other $200$ dimensions are for the diagonal variance. There is a sampling layer at the end to sample a $200$-dimensional vector from the Gaussian distribution, which is later used by the \model. 

\section{3D Shape Classification}

Here we present the details of our shape classification experiments. For each object, we take the responses of the second, third, and fourth convolution layers of the discriminator, and apply max pooling of kernel sizes $\{8,4,2\}$, respectively. We then concatenate the outputs into a vector of length $7,168$, which is later used by a linear SVM for training and classification. 

We use one-versus-all SVM classifiers. We use L2 penalty, balanced class weights, and intercept scaling during training. For ModelNet40, we train a linear SVM with penalty parameter $C=0.07$, and for ModelNet10, we have $C=0.01$. We also show the results with limited training data on both ModelNet40 and ModelNet10 in \fig{fig:classification_detail}.

\begin{figure}[h]
\centering
\includegraphics[width=.41\linewidth]{classification40.pdf}
\qquad
\includegraphics[width=.4\linewidth]{classification10.pdf} 
\caption{Classification accuracy with limited training data, on ModelNet40 and ModelNet10}
\label{fig:classification_detail}
\end{figure}

\section{\vaemodel Training}

Let $\{x_i,y_i\}$ be the set of training pairs, where $y_i$ is a 2D image and $x_i$ is the corresponding 3D shape. In each iteration $t$ of training, we first generate a random sample $z_t$ from $N(\mathbf{0},\mathbf{I})$\footnote{$\mathbf{I}$ is an identity matrix.}. Then we update the discriminator $D$, the image encoder $E$, and the generator $G$ sequentially. Specifically,

\begin{itemize}
\item Step 1: Update the discriminator $D$ by minimizing the following loss function:
\begin{align}
\log D(x_i) + \log (1-D(G(z_t))).
\end{align}

\item Step 2: Update the image encoder $E$ by minimizing the following loss function:
\begin{align}
D_{\text{KL}}\left(N(E_\text{mean}(y_i),E_\text{var}(y_i))\mid\mid N(\mathbf{0},\mathbf{I})\right) + ||G(E(y_i)) - x_i||_2,
\end{align}
where $E_\text{mean}(y_i)$ and $E_\text{var}(y_i) $ are the predicted mean and variance of the latent variable $z$, respectively.

\item Step 3: Update the generator $G$ by minimizing the following loss function:
\begin{align}
\log (1-D(G(z_t))) + ||G(E(y_i)) - x_i||_2.
\end{align}
\end{itemize}


\end{document}
